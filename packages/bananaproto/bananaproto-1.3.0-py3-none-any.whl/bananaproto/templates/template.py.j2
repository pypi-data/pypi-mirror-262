# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: {{ ', '.join(output_file.input_filenames) }}
# plugin: python-bananaproto
# This file has been @generated
{% for i in output_file.python_module_imports|sort %}
import {{ i }}
{% endfor %}

from dataclasses import dataclass

import bananaproto
{% if output_file.services %}
from bananaproto.grpc.grpclib_server import ServiceBase
import grpclib
{% endif %}

{% for i in output_file.imports|sort %}
{{ i }}
{% endfor %}

{% if output_file.imports_type_checking_only %}
from typing import TYPE_CHECKING

if TYPE_CHECKING:
{% for i in output_file.imports_type_checking_only|sort %}    {{ i }}
{% endfor %}
{% endif %}

{% if output_file.enums %}{% for enum in output_file.enums %}
class {{ enum.py_name }}(bananaproto.Enum):
    {% if enum.comment %}
{{ enum.comment }}

    {% endif %}
    {% for entry in enum.entries %}
    {{ entry.name }} = {{ entry.value }}
        {% if entry.comment %}
{{ entry.comment }}

        {% endif %}
    {% endfor %}


{% endfor %}
{% endif %}
{% for message in output_file.messages %}
@dataclass(eq=False, repr=False)
class {{ message.py_name }}(bananaproto.Message):
    {% if message.comment %}
{{ message.comment }}

    {% endif %}
    {% for field in message.fields %}
    {{ field.get_field_string() }}
        {% if field.comment %}
{{ field.comment }}

        {% endif %}
    {% endfor %}
    {% if not message.fields %}
    pass
    {% endif %}

    {% if message.deprecated or message.has_deprecated_fields %}
    def __post_init__(self) -> None:
        {% if message.deprecated %}
        warnings.warn("{{ message.py_name }} is deprecated", DeprecationWarning)
        {% endif %}
        super().__post_init__()
        {% for field in message.deprecated_fields %}
        if self.is_set("{{ field }}"):
            warnings.warn("{{ message.py_name }}.{{ field }} is deprecated", DeprecationWarning)
        {% endfor %}
    {%  endif %}

{% endfor %}
{% for service in output_file.services %}
class {{ service.py_name }}Stub(bananaproto.ServiceStub):
    {% if service.comment %}
{{ service.comment }}

    {% elif not service.methods %}
    pass
    {% endif %}
    {% for method in service.methods %}
    def {{ method.py_name }}(self,
        {%- if not method.client_streaming -%}
            {%- if method.py_input_message -%} msg: {{ method.py_input_message_type }}, {%- endif -%}
        {%- else -%}
            {# Client streaming: need a request iterator instead #}
            msg_iter: AsyncIterable[{{ method.py_input_message_type }}] | Iterable[{{ method.py_input_message_type }}],
        {%- endif -%}
            *,
            timeout: Optional[float] = None,
            deadline: Optional[Deadline] = None,
            metadata: Optional[MetadataLike] = None,
            ) -> {% if method.server_streaming %}AsyncIterator[{{ method.py_output_message_type }}] | Iterator[{{ method.py_output_message_type }}]{% else %}Awaitable[{{ method.py_output_message_type }}] | {{ method.py_output_message_type }}{% endif %}:
        {% if method.comment %}
{{ method.comment }}

        {% endif %}
        {% if method.server_streaming %}
            {% if method.client_streaming %}
        async_iter = self._stream_stream(
            "{{ method.route }}",
            msg_iter,
            {{ method.py_input_message_type }},
            {{ method.py_output_message_type.strip('"') }},
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )
        if self.synchronization_loop is None:
            return async_iter
        return self._deasync_aiter(async_iter)
            {% else %}{# i.e. not client streaming #}
        async_iter = self._unary_stream(
            "{{ method.route }}",
            msg,
            {{ method.py_output_message_type.strip('"') }},
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )
        if self.synchronization_loop is None:
            return async_iter
        return self._deasync_aiter(async_iter)

            {% endif %}{# if client streaming #}
        {% else %}{# i.e. not server streaming #}
            {% if method.client_streaming %}
        coro = self._stream_unary(
            "{{ method.route }}",
            msg_iter,
            {{ method.py_input_message_type }},
            {{ method.py_output_message_type.strip('"') }},
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )
        if self.synchronization_loop is None:
            return coro
        return self._deasync_coro(coro)
            {% else %}{# i.e. not client streaming #}
        coro = self._unary_unary(
            "{{ method.route }}",
            msg,
            {{ method.py_output_message_type.strip('"') }},
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )
        if self.synchronization_loop is None:
            return coro
        return self._deasync_coro(coro)
            {% endif %}{# client streaming #}
        {% endif %}

    {% endfor %}
{% endfor %}

{% for service in output_file.services %}
class {{ service.py_name }}Base(ServiceBase):
    {% if service.comment %}
{{ service.comment }}

    {% endif %}

    {% for method in service.methods %}
    async def {{ method.py_name }}(self,
        {%- if not method.client_streaming -%}
            {%- if method.py_input_message -%}msg: {{ method.py_input_message_type }}, {%- endif -%}
        {%- else -%}
            {# Client streaming: need a request iterator instead #}
            msg_iter: AsyncIterator[{{ method.py_input_message_type }}],
        {%- endif -%}
            metadata: MetadataLike,
            ) -> {% if method.server_streaming %}AsyncIterator[{{ method.py_output_message_type }}]{% else %}{{ method.py_output_message_type }}{% endif %}:
        {% if method.comment %}
{{ method.comment }}

        {% endif %}
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        {% if method.server_streaming %}
        {# Otherwise python does not understand that this is a generator #}
        yield {{ method.py_output_message_type }}()
        {% endif %}

    {% endfor %}

    {% for method in service.methods %}
    async def __rpc_{{ method.py_name }}(self, stream: grpclib.server.Stream[{{ method.py_input_message_type }}, {{ method.py_output_message_type }}]) -> None:
        {% if not method.client_streaming %}
        request = await stream.recv_message()
        {% else %}
        request = stream.__aiter__()
        {% endif %}
        try:
            {% if not method.server_streaming %}
            response = await self.{{ method.py_name }}(request, stream.metadata)
            await stream.send_message(response)
            {% else %}
            await self._call_rpc_handler_server_stream(
                self.{{ method.py_name }},
                stream,
                request,
                stream.metadata,
            )
            {% endif %}
        except grpclib.GRPCError:
            raise
        except Exception as exc:
            if len(exc.args) > 0:
                status_message = f"{exc.__class__.__name__}: {exc.args[0]}"
            else:
                status_message = f"{exc.__class__.__name__}"

            await stream.send_trailing_metadata(
                status=grpclib.const.Status.INTERNAL,
                status_message=status_message,
            )
            raise

    {% endfor %}

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
        {% for method in service.methods %}
        "{{ method.route }}": grpclib.const.Handler(
            self.__rpc_{{ method.py_name }},
            {% if not method.client_streaming and not method.server_streaming %}
            grpclib.const.Cardinality.UNARY_UNARY,
            {% elif not method.client_streaming and method.server_streaming %}
            grpclib.const.Cardinality.UNARY_STREAM,
            {% elif method.client_streaming and not method.server_streaming %}
            grpclib.const.Cardinality.STREAM_UNARY,
            {% else %}
            grpclib.const.Cardinality.STREAM_STREAM,
            {% endif %}
            {{ method.py_input_message_type }},
            {{ method.py_output_message_type }},
        ),
        {% endfor %}
        }

{% endfor %}
