# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_tens.ipynb.

# %% auto 0
__all__ = ['makeslcs', 'slcten', 'setslcs', 'slcswith', 'slcloc', 'slcval']

# %% ../nbs/03_tens.ipynb 6
from functools import wraps

# %% ../nbs/03_tens.ipynb 8
#| export


# %% ../nbs/03_tens.ipynb 10
try: import torch
except: ...

# %% ../nbs/03_tens.ipynb 12
from nlit import (COORD, SLICE)
from quac import axesidxsq, num, ints, intq, slicespecs, tensor, booltensor, nan
from chck import notnone, isnone
from asto import asslc

# %% ../nbs/03_tens.ipynb 14
from .atyp import SliceFormat, SliceFormats
from .util import (guess_slice_format, flip_slice_format, sdim, torchnans)

# %% ../nbs/03_tens.ipynb 17
def makeslcs(
    *slcs: slicespecs, 
    axes: ints | None = None, 
    ndim: intq = None, 
    fmt: SliceFormats = SliceFormat,
) -> list[slice]:     
    '''
    Convert tuples representing slices into actual Python slice objects.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.
        
    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    ndim : int, optional
        The number of dimensions of the target tensor, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    list[slice]
        A list of Python slice objects.

    Examples
    --------
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    '''
    # (x0, y0), (x1, y1) --> (x0, x1), (y0, y1)
    if isnone(fmt): 
        fmt = guess_slice_format(*slcs)
    
    if fmt == COORD: 
        slcs = flip_slice_format(*slcs)

    # Convert slcs tuples into slices
    slices = list(asslc(slc, __nones_ok=True) for slc in slcs)
    nslice = sdim(*slices, axes=axes, ndim=ndim)
    
    # Create a list of slice(None) for all dimensions
    axes = list([slice(None)] * nslice if isnone(axes) else axes)

    # Replace slices for specified axes
    slices = [slices[axes.index(i)] if i in axes else slice(None) for i in range(nslice)]
    return slices

# %% ../nbs/03_tens.ipynb 19
def slcten(
    tens: tensor,
    *slcs: slicespecs, 
    axes: ints = None, 
    fmt: SliceFormats = SliceFormat,
    inplace: bool = True, 
    __setval: tuple = None, 
    __retsub: bool = True
) -> tensor:
    '''
    Extract or modify a subslice of a tensor based on provided slice specifications.

    Parameters
    ----------
    tens : Tensor
        The tensor to slice or modify.
        
    slcs : Slcs
        Tuples representing the slices.
        
    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    inplace : bool, default: True
        If True, modify the tensor in place, defaults to True.
        
    __setval : tuple, optional
        The value to set the sliced region to, defaults to None.
        
    __retsub : bool, default: True
        If True, return the sliced part of the tensor, defaults to True.

    Returns
    -------
    Tensor
        The modified or extracted part of the tensor.

    Examples
    --------
    >>> slcten(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,))
    tensor([[1, 2]])
    '''
    if isnone(axes): 
        axes = (0, 1) if tens.ndim <= 3 else (1, 2)
    
    slcs = makeslcs(*slcs, axes=axes, ndim=tens.ndim, fmt=fmt)
    tout = tens[slcs] if __retsub else tens
    
    if notnone(__setval) and __retsub:
        return torch.ones_like(tout) * torch.tensor(__setval)
    
    tout = tens.clone() if not inplace else tout
    
    if notnone(__setval):
        tout[slcs] = torch.tensor(__setval)
        return tout
    
    return tout

# %% ../nbs/03_tens.ipynb 21
def setslcs(
    ten: tensor, 
    *slcs: slicespecs, 
    axes: axesidxsq = None, 
    fmt: SliceFormats = SliceFormat,
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''
    Apply a mask to a tensor (i.e. set `value` to the specified slices).

    Parameters
    ----------
    ten : Tensor
        The tensor to modify.

    slcs : Slcs
        Tuples representing the slices.

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    inplace : bool, default: False
        If True, modify the tensor in place, defaults to False.

    Returns
    -------
    Tensor
        The modified tensor.

    Examples
    --------
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    '''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=val, __retsub=False)

# %% ../nbs/03_tens.ipynb 23
def slcswith( 
     *slcs: slicespecs, 
     size: ints = (400, 400, 3), 
     axes: axesidxsq = None,
     fmt: SliceFormats = SliceFormat, 
     val: tuple | nan = torch.nan, 
     ttype: num | nan | type = torch.nan,
) -> tensor:
    '''
    Create a tensor of a specified size, applying a value to specified slices.
    
    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : tuple[ints, ...], default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    ttype : num | type, default: torch.nan
        The type of tensor to create, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified slices modified.

    Examples
    --------
    >>> slcswith((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1

    Notes
    -----
    - meant to represent "sliced with"
    '''
    tfunc = torch.zeros
    if ttype == torch.nan:   
        tfunc = torchnans
    
    if ttype == torch.bool:  
        tfunc = torch.ones
    
    if ttype == torch.zeros: 
        tfunc = torchnans

    return setslcs(tfunc(size), *slcs, axes=axes, fmt=fmt, val=val, inplace=True)     

# %% ../nbs/03_tens.ipynb 25
def slcloc(
    *slcs: slicespecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SliceFormat,
) -> booltensor:
    '''
    Convert slices to a boolean index tensor for a tensor of a given `size`.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    BoolTensor
        A boolean tensor indicating the locations of the slices.

    Examples
    --------
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    '''
    tens = slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=torch.nan, ttype=torch.zeros)     
    return tens.isnan() 

# %% ../nbs/03_tens.ipynb 27
def slcval(
    *slcs: slicespecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SliceFormat, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''
    Create a `tensor` of a specified `size`, applying a `value` only to specified `slices`.

    Parameters
    ----------
    slcs : Slcs
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], default: (0, 1)
        The axes that the slices apply to, defaults to (0, 1).

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified value applied to the slices.

    Examples
    --------
    >>> slcval((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    '''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=torch.nan)     

# %% ../nbs/03_tens.ipynb 29
#| export
