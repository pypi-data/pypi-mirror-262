# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_slcr.ipynb.

# %% auto 0
__all__ = ['slcten', 'slice_tensor', 'setslcs', 'set_slices', 'slcswith', 'slices_with', 'slices_tensor', 'slcloc',
           'slice_location', 'slice_loc', 'slcval', 'slice_val', 'slice_value']

# %% ../nbs/02_slcr.ipynb 6
from functools import wraps, partial, reduce

# %% ../nbs/02_slcr.ipynb 8
#| export


# %% ../nbs/02_slcr.ipynb 10
try: import torch
except: ...

# %% ../nbs/02_slcr.ipynb 12
from nlit import (SLICE)
from quac import (
    nan, num, ints, tupleq, 
    tensor, booltensor, axesidxsq,
    
)
from chck import notnone, isnone
from asto import (SliceFormats, torchnans, makeslcs, SliceSpecs)

# %% ../nbs/02_slcr.ipynb 14
from .cons import WRAPS_ASSIGN_ANNDOCS

# %% ../nbs/02_slcr.ipynb 17
def slcten(
    ten: tensor,
    *slcs: SliceSpecs, 
    axes: ints | None = None, 
    fmt: SliceFormats = SLICE,
    inplace: bool = True, 
    __setval: tupleq = None, 
    __retsub: bool = True
) -> tensor:
    '''Extract or modify a subslice of a tensor based on provided slice specifications.

    Parameters
    ----------
    ten : tensor
        The tensor to slice or modify.
        
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.
        
    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    inplace : bool, default: True
        If True, modify the tensor in place, defaults to True.
        
    __setval : tuple, optional
        The value to set the sliced region to, defaults to None.
        
    __retsub : bool, default: True
        If True, return the sliced part of the tensor, defaults to True.

    Returns
    -------
    tensor
        The modified or extracted part of the tensor.
    
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcten(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,))
    tensor([[1, 2]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slice_tensor : Alias for slcten
    '''
    if isnone(axes): 
        axes = (0, 1) if ten.ndim <= 3 else (1, 2)
    
    slcs = makeslcs(*slcs, axes=axes, ndim=ten.ndim, fmt=fmt)
    tout = ten[slcs] if __retsub else ten
    
    if notnone(__setval) and __retsub:
        return torch.ones_like(tout) * torch.tensor(__setval)
    
    tout = ten.clone() if not inplace else tout
    
    if notnone(__setval):
        tout[slcs] = torch.tensor(__setval)
        return tout
    
    return tout

@wraps(slcten, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_tensor(
    ten: tensor,
    *slcs: SliceSpecs, 
    axes: ints | None = None, 
    fmt: SliceFormats = SLICE,
    inplace: bool = True, 
    __setval: tupleq = None, 
    __retsub: bool = True
) -> tensor:
    '''Alias for `slcten`'''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=__setval, __retsub=__retsub)

# %% ../nbs/02_slcr.ipynb 19
def setslcs(
    ten: tensor, 
    *slcs: SliceSpecs, 
    axes: axesidxsq = None, 
    fmt: SliceFormats = SLICE,
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''
    Apply a mask to a tensor (i.e. set `value` to the specified slices).

    Parameters
    ----------
    ten : Tensor
        The tensor to modify.

    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    inplace : bool, default: False
        If True, modify the tensor in place, defaults to False.

    Returns
    -------
    tensor
        The modified tensor.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    set_slices: Alias for setslcs
    slcten : Extract or modify a subslice of a tensor based on provided slice specifications
    slice_tensor: Alias for slcten
    '''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=val, __retsub=False)


@wraps(setslcs, assigned=WRAPS_ASSIGN_ANNDOCS)
def set_slices(
    ten: tensor, 
    *slcs: SliceSpecs, 
    axes: axesidxsq = None, 
    fmt: SliceFormats = SLICE,
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''Alias for `setslcs`'''
    return setslcs(ten, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)

# %% ../nbs/02_slcr.ipynb 21
def slcswith( 
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    ttype: num | nan | type = torch.nan,
) -> tensor:
    '''
    Create a tensor of a specified size, applying a value to specified slices.
    
    Parameters
    ----------
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    size : tuple[ints, ...], default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    ttype : num | type, default: torch.nan
        The type of tensor to create, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified slices modified.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcswith((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slices_with : Alias for slcswith.
    slices_tensor : Alias for slcswith.
    setslcs : Apply a mask to a tensor (i.e. set value to the specified slices).
    set_slices: Alias for setslcs.
    '''
    tfunc = torch.zeros
    if ttype == torch.nan:   
        tfunc = torchnans
    
    if ttype == torch.bool:  
        tfunc = torch.ones
    
    if ttype == torch.zeros: 
        tfunc = torchnans

    return setslcs(tfunc(size), *slcs, axes=axes, fmt=fmt, val=val, inplace=True)   


@wraps(slcswith, assigned=WRAPS_ASSIGN_ANNDOCS)
def slices_with(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    ttype: num | nan | type = torch.nan,
) -> tensor:
    '''Alias for `slcswith`'''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=ttype)


@wraps(slcswith, assigned=WRAPS_ASSIGN_ANNDOCS)
def slices_tensor(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    ttype: num | nan | type = torch.nan,
) -> tensor:
    '''Alias for `slcswith`'''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=ttype)

# %% ../nbs/02_slcr.ipynb 23
def slcloc(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE,
) -> booltensor:
    '''
    Convert slices to a boolean index tensor for a tensor of a given `size`.

    Parameters
    ----------
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    booltensor
        A boolean tensor indicating the locations of the slices.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slcswith : Create a tensor of a specified size, applying a value to specified slices.
    slices_with : Alias for slcswith.
    slices_tensor : Alias for slcswith.
    slice_loc: Alias for slcloc.
    slice_location: Alias for slcloc.
    setslcs : Apply a mask to a tensor (i.e. set value to the specified slices).
    '''
    tens = slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=torch.nan, ttype=torch.zeros)     
    return tens.isnan() 


@wraps(slcloc, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_location(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE,
) -> tensor:
    '''Alias for `slcloc`'''
    return slcloc(*slcs, size=size, axes=axes, fmt=fmt)


@wraps(slcloc, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_loc(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE,
) -> tensor:
    '''Alias for `slcloc`'''
    return slcloc(*slcs, size=size, axes=axes, fmt=fmt)

# %% ../nbs/02_slcr.ipynb 25
def slcval(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''
    Create a `tensor` of a specified `size`, applying a `value` only to specified `slices`.

    Parameters
    ----------
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], default: (0, 1)
        The axes that the slices apply to, defaults to (0, 1).

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified value applied to the slices.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcval((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slcswith : Create a tensor of a specified size, applying a value to specified slices.
    slices_with : Alias for slcswith.
    slice_val: Alias for slcval.
    slice_value: Alias for slcval.
    '''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=torch.nan)    


@wraps(slcval, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_val(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''Alias for `slcval`'''
    return slcval(*slcs, size=size, axes=axes, fmt=fmt, val=val)

@wraps(slcval, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_value(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''Alias for `slcval`'''
    return slcval(*slcs, size=size, axes=axes, fmt=fmt, val=val)

# %% ../nbs/02_slcr.ipynb 27
#| export
