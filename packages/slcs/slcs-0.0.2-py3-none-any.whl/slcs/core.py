# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_mskr.ipynb.

# %% auto 0
__all__ = ['slcten', 'slice_tensor', 'setslcs', 'set_slices', 'slcswith', 'slices_with', 'slices_tensor', 'slcloc',
           'slice_location', 'slice_loc', 'slcval', 'slice_val', 'slice_value', 'mask', 'maskwith', 'mask_with',
           'bboxmask', 'mask_bbox', 'make_bbox_mask', 'reducemasks', 'resize_reduce_masks', 'applymasks',
           'use_mask_info', 'applymaskinfo', 'applyminfo', 'masktens', 'mask_many', 'maskmany', 'mask_tensors',
           'repeatapply']

# %% ../nbs/03_mskr.ipynb 6
from functools import wraps, partial, reduce

# %% ../nbs/03_mskr.ipynb 8
#| export


# %% ../nbs/03_mskr.ipynb 10
try: import torch
except: ...

# %% ../nbs/03_mskr.ipynb 12
from nlit import (COORD, SLICE, SIZE, MASKS)
from quac import (
    nan, num, ints, intq, tupleq, 
    tensor, booltensor, 
    slicespecs, axesidxsq,
    bbox as BBox, size as Size, color as Color
)
from chck import notnone, isnone
from asto import (
    SliceFormats, asslc, guess_slice_format, flip_slice_format, torchnans,
    channels_resize, slice_dims, makeslcs, SliceSpecs
)

# %% ../nbs/03_mskr.ipynb 14
from .cons import WRAPS_ASSIGN_ANNDOCS
from .atyp import MaskInfo

# %% ../nbs/03_mskr.ipynb 17
def slcten(
    ten: tensor,
    *slcs: SliceSpecs, 
    axes: ints | None = None, 
    fmt: SliceFormats = SLICE,
    inplace: bool = True, 
    __setval: tupleq = None, 
    __retsub: bool = True
) -> tensor:
    '''Extract or modify a subslice of a tensor based on provided slice specifications.

    Parameters
    ----------
    ten : tensor
        The tensor to slice or modify.
        
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.
        
    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    inplace : bool, default: True
        If True, modify the tensor in place, defaults to True.
        
    __setval : tuple, optional
        The value to set the sliced region to, defaults to None.
        
    __retsub : bool, default: True
        If True, return the sliced part of the tensor, defaults to True.

    Returns
    -------
    tensor
        The modified or extracted part of the tensor.
    
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcten(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,))
    tensor([[1, 2]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slice_tensor : Alias for slcten
    '''
    if isnone(axes): 
        axes = (0, 1) if ten.ndim <= 3 else (1, 2)
    
    slcs = makeslcs(*slcs, axes=axes, ndim=ten.ndim, fmt=fmt)
    tout = ten[slcs] if __retsub else ten
    
    if notnone(__setval) and __retsub:
        return torch.ones_like(tout) * torch.tensor(__setval)
    
    tout = ten.clone() if not inplace else tout
    
    if notnone(__setval):
        tout[slcs] = torch.tensor(__setval)
        return tout
    
    return tout

@wraps(slcten, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_tensor(
    ten: tensor,
    *slcs: SliceSpecs, 
    axes: ints | None = None, 
    fmt: SliceFormats = SLICE,
    inplace: bool = True, 
    __setval: tupleq = None, 
    __retsub: bool = True
) -> tensor:
    '''Alias for `slcten`'''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=__setval, __retsub=__retsub)

# %% ../nbs/03_mskr.ipynb 19
def setslcs(
    ten: tensor, 
    *slcs: SliceSpecs, 
    axes: axesidxsq = None, 
    fmt: SliceFormats = SLICE,
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''
    Apply a mask to a tensor (i.e. set `value` to the specified slices).

    Parameters
    ----------
    ten : Tensor
        The tensor to modify.

    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    inplace : bool, default: False
        If True, modify the tensor in place, defaults to False.

    Returns
    -------
    tensor
        The modified tensor.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    set_slices: Alias for setslcs
    slcten : Extract or modify a subslice of a tensor based on provided slice specifications
    slice_tensor: Alias for slcten
    '''
    return slcten(ten, *slcs, axes=axes, fmt=fmt, inplace=inplace, __setval=val, __retsub=False)


@wraps(setslcs, assigned=WRAPS_ASSIGN_ANNDOCS)
def set_slices(
    ten: tensor, 
    *slcs: SliceSpecs, 
    axes: axesidxsq = None, 
    fmt: SliceFormats = SLICE,
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''Alias for `setslcs`'''
    return setslcs(ten, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)

# %% ../nbs/03_mskr.ipynb 21
def slcswith( 
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    ttype: num | nan | type = torch.nan,
) -> tensor:
    '''
    Create a tensor of a specified size, applying a value to specified slices.
    
    Parameters
    ----------
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    size : tuple[ints, ...], default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.
        
    ttype : num | type, default: torch.nan
        The type of tensor to create, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified slices modified.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcswith((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slices_with : Alias for slcswith.
    slices_tensor : Alias for slcswith.
    setslcs : Apply a mask to a tensor (i.e. set value to the specified slices).
    set_slices: Alias for setslcs.
    '''
    tfunc = torch.zeros
    if ttype == torch.nan:   
        tfunc = torchnans
    
    if ttype == torch.bool:  
        tfunc = torch.ones
    
    if ttype == torch.zeros: 
        tfunc = torchnans

    return setslcs(tfunc(size), *slcs, axes=axes, fmt=fmt, val=val, inplace=True)   


@wraps(slcswith, assigned=WRAPS_ASSIGN_ANNDOCS)
def slices_with(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    ttype: num | nan | type = torch.nan,
) -> tensor:
    '''Alias for `slcswith`'''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=ttype)


@wraps(slcswith, assigned=WRAPS_ASSIGN_ANNDOCS)
def slices_tensor(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    ttype: num | nan | type = torch.nan,
) -> tensor:
    '''Alias for `slcswith`'''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=ttype)

# %% ../nbs/03_mskr.ipynb 23
def slcloc(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE,
) -> booltensor:
    '''
    Convert slices to a boolean index tensor for a tensor of a given `size`.

    Parameters
    ----------
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], optional
        The axes that the slices apply to, defaults to None.
        
    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.

    Returns
    -------
    booltensor
        A boolean tensor indicating the locations of the slices.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slcswith : Create a tensor of a specified size, applying a value to specified slices.
    slices_with : Alias for slcswith.
    slices_tensor : Alias for slcswith.
    slice_loc: Alias for slcloc.
    slice_location: Alias for slcloc.
    setslcs : Apply a mask to a tensor (i.e. set value to the specified slices).
    '''
    tens = slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=torch.nan, ttype=torch.zeros)     
    return tens.isnan() 


@wraps(slcloc, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_location(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE,
) -> tensor:
    '''Alias for `slcloc`'''
    return slcloc(*slcs, size=size, axes=axes, fmt=fmt)


@wraps(slcloc, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_loc(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: axesidxsq = None,
    fmt: SliceFormats = SLICE,
) -> tensor:
    '''Alias for `slcloc`'''
    return slcloc(*slcs, size=size, axes=axes, fmt=fmt)

# %% ../nbs/03_mskr.ipynb 25
def slcval(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''
    Create a `tensor` of a specified `size`, applying a `value` only to specified `slices`.

    Parameters
    ----------
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices.

    size : ints, default: (400, 400, 3)
        The size of the tensor to create, defaults to (400, 400, 3).

    axes : tuple[int, ...], default: (0, 1)
        The axes that the slices apply to, defaults to (0, 1).

    fmt : SliceFormats, default: 'slice'
        The format of the slices, either 'coord' or 'slice', defaults to 'slice'.
        
    val : tuple | nan, default: torch.nan
        The value to apply to the slices, defaults to NaN.

    Returns
    -------
    Tensor
        The created tensor with the specified value applied to the slices.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> slcval((0, 100), (0, 100), size=(200, 200), val=1)
    # Returns a 200x200 tensor with the top-left 100x100 block set to 1
    
    >>> slcloc((0, 100), (0, 100), size=(200, 200))
    # Returns a 200x200 boolean tensor with True in the top-left 100x100 block
    
    >>> setslcs(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])
    
    >>> makeslcs((0, 10), (0, 10))
    [slice(0, 10, None), slice(0, 10, None)]
    
    >>> slices = (0, 5), (2, 10) # slice format: (x0, x1), (y0, y1)
    ... tocoordformat(slices) # convert to coordinate format
    ((0, 2), (5, 10)) 

    >>> coords = (0, 2), (5, 10) # coord format: (x0, y0), (x1, y1)
    ... tosliceformat(coords) # convert to slice format
    ((0, 5), (2, 10))
    
    See Also
    --------
    slcswith : Create a tensor of a specified size, applying a value to specified slices.
    slices_with : Alias for slcswith.
    slice_val: Alias for slcval.
    slice_value: Alias for slcval.
    '''
    return slcswith(*slcs, size=size, axes=axes, fmt=fmt, val=val, ttype=torch.nan)    


@wraps(slcval, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_val(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''Alias for `slcval`'''
    return slcval(*slcs, size=size, axes=axes, fmt=fmt, val=val)

@wraps(slcval, assigned=WRAPS_ASSIGN_ANNDOCS)
def slice_value(
    *slcs: SliceSpecs, 
    size: ints = (400, 400, 3), 
    axes: ints = (0, 1), 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan,
) -> tensor:
    '''Alias for `slcval`'''
    return slcval(*slcs, size=size, axes=axes, fmt=fmt, val=val)

# %% ../nbs/03_mskr.ipynb 27
def mask(
    t: tensor, 
    *slcs: tuple,  
    axes: tupleq = None, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = False,
) -> tensor:
    '''
    Apply a mask to a tensor at specified slices.

    Parameters
    ----------
    t : tensor
        The tensor to apply the mask to.
    
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices to apply the mask.
    
    axes : tuple[int, ....], optional
        The axes corresponding to the slices, defaults to None.
    
    fmt : SliceFormat, default: 'slice'
        Format of the slices, either 'coord' or 'slice', defaults to 'slice'.
    
    val : tuple | nan, default: torch.nan
        The value to use for the mask, defaults to NaN.
    
    inplace : bool, default: False
        Whether to apply the mask in place, defaults to False.

    Returns
    -------
    tensor
        The masked tensor.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> mask(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])

    See Also
    --------
    setslcs : Set values at specified slices.
    set_slices : Alias for setslcs.
    maskwith: Alias for mask.
    mask_with: Alias for mask.
    '''
    return setslcs(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)


@wraps(mask, assigned=WRAPS_ASSIGN_ANNDOCS)
def maskwith(
    t: tensor, 
    *slcs: tuple,  
    axes: tupleq = None, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''Alias for mask'''
    return mask(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)


@wraps(mask, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_with(
    t: tensor, 
    *slcs: tuple,  
    axes: tupleq = None, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''Alias for mask'''
    return mask(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)

# %% ../nbs/03_mskr.ipynb 29
def bboxmask(
     bbox: BBox, 
     size: Size = (400, 400, 3), 
     color: Color = (0, 0, 0)
) -> tensor:
     '''
     Create a mask tensor with a bounding box applied.

     Parameters
     ----------
     bbox : bbox
          The bounding box coordinates.
          
     size : Size, default: (400, 400, 3)
          The size of the tensor to create, defaults to (400, 400, 3).
          
     color : Color, default: (0, 0, 0)
          The color to fill the bounding box, defaults to (0, 0, 0).

     Returns
     -------
     tensor
          The tensor with a bounding box mask applied.

     Examples
     --------
     >>> bboxmask(((0, 0), (100, 100)))
     # Returns a tensor with the top-left 100x100 region colored.
     
     See Also
     --------
     mask_bbox : Alias for bboxmask.
     make_bbox_mask : Alias for bboxmask.
     '''
     return mask(torchnans(size), *bbox, axes=(0, 1), fmt=COORD, val=color, inplace=False)


@wraps(bboxmask, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_bbox(
     bbox: BBox, 
     size: Size = (400, 400, 3), 
     color: Color = (0, 0, 0)
) -> tensor:
    '''Alias for bboxmask'''
    return bboxmask(bbox, size=size, color=color)


@wraps(bboxmask, assigned=WRAPS_ASSIGN_ANNDOCS)
def make_bbox_mask(
     bbox: BBox, 
     size: Size = (400, 400, 3), 
     color: Color = (0, 0, 0)
) -> tensor:
    '''Alias for bboxmask'''
    return bboxmask(bbox, size=size, color=color)

# %% ../nbs/03_mskr.ipynb 31
def reducemasks(
    t: tensor, 
    masks: list, 
    msize: tuple = (400, 400),
    axes: tupleq = None, 
    fmt: SliceFormats = COORD,
    val: tuple = (0, 0, 0), 
    inplace: bool = False,
) -> tensor:
    '''
    Apply multiple masks to a tensor and resize it.

    Parameters
    ----------
    t : tensor
        The tensor to apply the masks to.
        
    masks : list
        A list of masks to apply.
        
    msize : tuple, default: (400, 400)
        The size to resize the tensor to after applying masks, defaults to (400, 400).
        
    axes : tuple, optional
        The axes corresponding to the masks, defaults to None.
        
    fmt : SliceFormat, default: 'coord'
        Format of the slices in the masks, defaults to 'coord'.
        
    val : tuple, default: (0, 0, 0)
        The value to use for the masks, defaults to (0, 0, 0).
        
    inplace : bool, optional
        Whether to apply the masks in place, defaults to False.

    Returns
    -------
    tensor
        The masked and resized tensor.

    Examples
    --------
    >>> reducemasks(torch.tensor([[1, 2], [3, 4]]), [((0, 1),)], val=0)
    # Returns the tensor with a mask applied and resized.
    
    See Also
    --------
    resize_reduce_masks : Alias for reducemasks.
    '''
    apply = partial(mask, val=val, axes=axes, fmt=fmt, inplace=inplace)
    return reduce(lambda v, m: apply(v, *m), masks, channels_resize(t, size=msize))


@wraps(reducemasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def resize_reduce_masks(
    t: tensor, 
    masks: list, 
    msize: tuple = (400, 400),
    axes: tupleq = None, 
    fmt: SliceFormats = COORD,
    val: tuple = (0, 0, 0), 
    inplace: bool = False,
) -> tensor:
    '''Alias for reducemasks'''
    return reducemasks(t, masks, msize, axes, fmt, val, inplace)

# %% ../nbs/03_mskr.ipynb 33
def applymasks(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''
    Apply masks from MaskInfo to a tensor and resize it.

    Parameters
    ----------
    t : tensor
        The tensor to apply the masks to.
        
    minfo : MaskInfo
        Mask information containing size, masks, and value.
    
    axes : tuple, default: (1, 2)
        The axes corresponding to the masks, defaults to (1, 2).
    
    ndim : int, default: 4
        The number of dimensions in the tensor, defaults to 4.
    
    fmt : SliceFormat, default: 'slice'
        Format of the slices in the masks, defaults to 'slice'.
    
    val : tuple, default: (0, 0, 0)
        The value to use for the masks, defaults to (0, 0, 0).
    
    inplace : bool, default: True
        Whether to apply the masks in place, defaults to True.
    
    outsize : tuple, default: (32, 32)
        The size to resize the tensor to after applying masks, defaults to (32, 32).

    Returns
    -------
    tensor
        The masked and resized tensor.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> applymasks(torch.rand(3, 400, 400), minfo)
    # Returns the tensor with masks applied and resized.
    
    
    See Also
    --------
    applyminfo : 
        Alias for applymasks.
    
    use_mask_info : 
        Alias for applymasks.
    
    applymaskinfo : 
        Alias for applymasks.    
    
    reducemasks : 
        Apply multiple masks to a tensor and resize it.
        
    asto.chns.channels_resize : 
        Resize the tensor to a specific size adjusting channels format if needed.
    '''
    if isnone(ndim): 
        ndim = t.ndim
    
    msize, masks = minfo[SIZE], minfo[MASKS]
    
    masks = tuple(makeslcs(*slcs,  axes=axes, ndim=ndim, fmt=fmt) for slcs in masks.values())
    mtens = reducemasks(t, masks, msize=msize, axes=axes, fmt=fmt, inplace=inplace, val=val)
    return channels_resize(mtens, outsize)
    
    
@wraps(applymasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def use_mask_info(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for applymasks.''';
    return applymasks(t, minfo, axes, ndim, fmt, val, inplace, outsize)


@wraps(applymasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def applymaskinfo(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for applymasks.''';
    return applymasks(t, minfo, axes, ndim, fmt, val, inplace, outsize)


@wraps(applymasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def applyminfo(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for applymasks.''';
    return applymasks(t, minfo, axes, ndim, fmt, val, inplace, outsize)

# %% ../nbs/03_mskr.ipynb 35
def masktens(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''
    Apply masks from MaskInfo to a list of tensors and resize them.

    Parameters
    ----------
    tens : list
        A list of tensors to apply the masks to.
        
    minfo : MaskInfo
        Mask information containing size, masks, and value.
        
    axes : tuple, default: (1, 2)
        The axes corresponding to the masks, defaults to (1, 2).
        
    ndim : int, default: 4
        The number of dimensions in the tensors, defaults to 4.
        
    fmt : SliceFormat, optional
        Format of the slices in the masks, defaults to 'slice'.
        
    val : tuple | nan, default: torch.nan
        The value to use for the masks, defaults to NaN.
        
    inplace : bool, default: True
        Whether to apply the masks in place, defaults to True.
        
    outsize : tuple, default: (32, 32)
        The size to resize the tensors to after applying masks, defaults to (32, 32).

    Returns
    -------
    tensor
        A list of masked and resized tensors.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> masktens([torch.rand(3, 400, 400)], minfo)
    # Returns a list of tensors with masks applied and resized.
    
    See Also
    --------
    maskmany : Alias for masktens.
    mask_many : Alias for masktens.
    mask_tensors : Alias for masktens.
    repeatapply : Alias for masktens.
    applymasks : Apply masks from MaskInfo to a tensor and resize it.
    reducemasks : Apply multiple masks to a tensor and resize it.
    '''
    res = [applymasks(s, minfo, axes, ndim, fmt, val, inplace, outsize) for s in tens]
    return torch.stack(res)


@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_many(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)

@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def maskmany(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)

@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_tensors(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)


@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def repeatapply(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)

# %% ../nbs/03_mskr.ipynb 37
#| export
