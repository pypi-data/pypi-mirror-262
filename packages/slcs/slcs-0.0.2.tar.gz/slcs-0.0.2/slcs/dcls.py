# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/09_dcls.ipynb.

# %% auto 0
__all__ = ['Slice']

# %% ../nbs/09_dcls.ipynb 6
from dataclasses import dataclass, field

# %% ../nbs/09_dcls.ipynb 8
#| export


# %% ../nbs/09_dcls.ipynb 10
#| export


# %% ../nbs/09_dcls.ipynb 12
from nlit import (SLICE, NUMPY, PANDAS, DICT, LIST, TUPLE)
from quac import nparray, series

# %% ../nbs/09_dcls.ipynb 14
from .atyp import intfloatq

# %% ../nbs/09_dcls.ipynb 16
@dataclass
class Slice:
    '''A class for representing a slice and providing conversion to other formats.
    
    Parameters
    ----------
    slc : slice
        The slice object to be represented and manipulated.
    
    Attributes
    ----------
    _start : int, optional
        The start of the slice. Defaults to None.
        
    _stop : int, optional
        The stop of the slice. Defaults to None.
        
    _step : int, optional
        The step of the slice. Defaults to None.
        
    Methods
    -------
    totuple() -> tuple[int, int, int]:
        Converts the slice to a tuple.
        
    toslice() -> slice:
        Returns a slice object from the stored start, stop, and step.
        
    tolist() -> list[int]:
        Converts the slice to a list.
        
    todict() -> dict:
        Converts the slice to a dictionary.
        
    astype(dtype: str):
        Converts the slice to a specified format.
    '''
    slc: slice = field(default_factory=slice)

    @property
    def start(self) -> int:
        '''Returns the start index of the slice.'''
        try: return self._start
        except AttributeError: self._start = self.slc.start
        return self._start
    
    @start.setter
    def start(self, value):
        '''Sets the start index.'''
        if value < 0: raise ValueError('Slice indices must be non-negative.')
        self._start = value

    @property
    def stop(self) -> int:
        '''Returns the stop index of the slice.'''
        try: return self._stop
        except AttributeError: self._stop = self.slc.stop
        return self._stop
    
    @stop.setter
    def stop(self, value):
        '''Sets the stop index.'''
        if value < 0:
            raise ValueError('Slice indices must be non-negative.')
        self._stop = value
    
    @property
    def step(self) -> int:
        '''Gets the step index.'''
        try: return self._step
        except AttributeError: self._step = self.slc.step
        return self._step
    
    @step.setter
    def step(self, value):
        '''Sets the step index.'''
        if value < 0: raise ValueError('Slice step must be non-negative.')
        self._step = value
    
    def __post_init__(self):
        '''Initializes default values for start, stop, and step if they are not provided.'''
        if self.start is None:
            self.start = 0

        if self.stop is None:
            self.stop = min(0, self.start, max(1, self.start))

        if self.step is None:
            self.step = 1

    def totuple(self) -> tuple[intfloatq, intfloatq, intfloatq]:
        '''Converts the slice to a tuple.'''
        return (self.start, self.stop, self.step)
    
    def toslice(self) -> slice:
        '''Converts the updated slice.'''
        return slice(self.start, self.stop, self.step)
    
    def tolist(self) -> list[int | float]:
        '''Converts the slice to a list.'''
        return list(range(self.start, self.stop, self.step))
    
    def todict(self) -> list[int | float]:
        '''Converts the slice to a dict.'''
        return dict(zip('start stop step'.split(), self.totuple()))
        
    def astype(self, dtype:str):
        '''Converts the slice to a specified format.
        
        Parameters
        ----------
        dtype : str
            The desired format ('list', 'numpy', 'pandas', 'tuple', 'dict', or 'slice').
        
        Returns
        -------
        Various types
            The slice converted to the specified format.
        '''
        if dtype in {LIST, list}:
            return self.tolist()
        elif dtype in {NUMPY, nparray}:
            try: import numpy as np
            except: ...
            return np.array(self.tolist())
        elif dtype in {PANDAS, series}:
            try: import pandas as pd
            except: ...
            return pd.Series(self.tolist())
        elif dtype in {TUPLE, tuple}:
            return self.totuple()
        elif dtype in {DICT, dict}:
            return self.todict()
        elif dtype in {SLICE, slice}:
            return self.toslice()
        return self

# %% ../nbs/09_dcls.ipynb 18
#| export
