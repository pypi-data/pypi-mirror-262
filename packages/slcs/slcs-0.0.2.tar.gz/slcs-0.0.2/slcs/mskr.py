# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_mskr.ipynb.

# %% auto 0
__all__ = ['mask', 'maskwith', 'mask_with', 'bboxmask', 'mask_bbox', 'make_bbox_mask', 'reducemasks', 'resize_reduce_masks',
           'applymasks', 'use_mask_info', 'applymaskinfo', 'applyminfo', 'masktens', 'mask_many', 'maskmany',
           'mask_tensors', 'repeatapply']

# %% ../nbs/03_mskr.ipynb 6
from functools import wraps, partial, reduce

# %% ../nbs/03_mskr.ipynb 8
#| export


# %% ../nbs/03_mskr.ipynb 10
try: import torch
except: ...

# %% ../nbs/03_mskr.ipynb 12
from nlit import (COORD, SLICE, SIZE, MASKS)
from quac import (nan, tupleq, tensor, bbox as BBox, size as Size, color as Color)
from chck import isnone
from asto import (SliceFormats, torchnans, channels_resize, makeslcs)

# %% ../nbs/03_mskr.ipynb 14
from .cons import WRAPS_ASSIGN_ANNDOCS
from .atyp import MaskInfo
from .slcr import setslcs

# %% ../nbs/03_mskr.ipynb 16
def mask(
    t: tensor, 
    *slcs: tuple,  
    axes: tupleq = None, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = False,
) -> tensor:
    '''
    Apply a mask to a tensor at specified slices.

    Parameters
    ----------
    t : tensor
        The tensor to apply the mask to.
    
    slcs : Iterable[SliceSpec | tuple[int, int, int] | tuple[int, ...]]
        Tuples representing the slices to apply the mask.
    
    axes : tuple[int, ....], optional
        The axes corresponding to the slices, defaults to None.
    
    fmt : SliceFormat, default: 'slice'
        Format of the slices, either 'coord' or 'slice', defaults to 'slice'.
    
    val : tuple | nan, default: torch.nan
        The value to use for the mask, defaults to NaN.
    
    inplace : bool, default: False
        Whether to apply the mask in place, defaults to False.

    Returns
    -------
    tensor
        The masked tensor.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> mask(torch.tensor([[1, 2], [3, 4]]), (0, 1), axes=(0,), val=0)
    tensor([[0, 0], [3, 4]])

    See Also
    --------
    setslcs : Set values at specified slices.
    set_slices : Alias for setslcs.
    maskwith: Alias for mask.
    mask_with: Alias for mask.
    '''
    return setslcs(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)


@wraps(mask, assigned=WRAPS_ASSIGN_ANNDOCS)
def maskwith(
    t: tensor, 
    *slcs: tuple,  
    axes: tupleq = None, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''Alias for mask'''
    return mask(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)


@wraps(mask, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_with(
    t: tensor, 
    *slcs: tuple,  
    axes: tupleq = None, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = False
) -> tensor:
    '''Alias for mask'''
    return mask(t, *slcs, axes=axes, fmt=fmt, val=val, inplace=inplace)

# %% ../nbs/03_mskr.ipynb 18
def bboxmask(
     bbox: BBox, 
     size: Size = (400, 400, 3), 
     color: Color = (0, 0, 0)
) -> tensor:
     '''
     Create a mask tensor with a bounding box applied.

     Parameters
     ----------
     bbox : bbox
          The bounding box coordinates.
          
     size : Size, default: (400, 400, 3)
          The size of the tensor to create, defaults to (400, 400, 3).
          
     color : Color, default: (0, 0, 0)
          The color to fill the bounding box, defaults to (0, 0, 0).

     Returns
     -------
     tensor
          The tensor with a bounding box mask applied.

     Examples
     --------
     >>> bboxmask(((0, 0), (100, 100)))
     # Returns a tensor with the top-left 100x100 region colored.
     
     See Also
     --------
     mask_bbox : Alias for bboxmask.
     make_bbox_mask : Alias for bboxmask.
     '''
     return mask(torchnans(size), *bbox, axes=(0, 1), fmt=COORD, val=color, inplace=False)


@wraps(bboxmask, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_bbox(
     bbox: BBox, 
     size: Size = (400, 400, 3), 
     color: Color = (0, 0, 0)
) -> tensor:
    '''Alias for bboxmask'''
    return bboxmask(bbox, size=size, color=color)


@wraps(bboxmask, assigned=WRAPS_ASSIGN_ANNDOCS)
def make_bbox_mask(
     bbox: BBox, 
     size: Size = (400, 400, 3), 
     color: Color = (0, 0, 0)
) -> tensor:
    '''Alias for bboxmask'''
    return bboxmask(bbox, size=size, color=color)

# %% ../nbs/03_mskr.ipynb 20
def reducemasks(
    t: tensor, 
    masks: list, 
    msize: tuple = (400, 400),
    axes: tupleq = None, 
    fmt: SliceFormats = COORD,
    val: tuple = (0, 0, 0), 
    inplace: bool = False,
) -> tensor:
    '''
    Apply multiple masks to a tensor and resize it.

    Parameters
    ----------
    t : tensor
        The tensor to apply the masks to.
        
    masks : list
        A list of masks to apply.
        
    msize : tuple, default: (400, 400)
        The size to resize the tensor to after applying masks, defaults to (400, 400).
        
    axes : tuple, optional
        The axes corresponding to the masks, defaults to None.
        
    fmt : SliceFormat, default: 'coord'
        Format of the slices in the masks, defaults to 'coord'.
        
    val : tuple, default: (0, 0, 0)
        The value to use for the masks, defaults to (0, 0, 0).
        
    inplace : bool, optional
        Whether to apply the masks in place, defaults to False.

    Returns
    -------
    tensor
        The masked and resized tensor.

    Examples
    --------
    >>> reducemasks(torch.tensor([[1, 2], [3, 4]]), [((0, 1),)], val=0)
    # Returns the tensor with a mask applied and resized.
    
    See Also
    --------
    resize_reduce_masks : Alias for reducemasks.
    '''
    apply = partial(mask, val=val, axes=axes, fmt=fmt, inplace=inplace)
    return reduce(lambda v, m: apply(v, *m), masks, channels_resize(t, size=msize))


@wraps(reducemasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def resize_reduce_masks(
    t: tensor, 
    masks: list, 
    msize: tuple = (400, 400),
    axes: tupleq = None, 
    fmt: SliceFormats = COORD,
    val: tuple = (0, 0, 0), 
    inplace: bool = False,
) -> tensor:
    '''Alias for reducemasks'''
    return reducemasks(t, masks, msize, axes, fmt, val, inplace)

# %% ../nbs/03_mskr.ipynb 22
def applymasks(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''
    Apply masks from MaskInfo to a tensor and resize it.

    Parameters
    ----------
    t : tensor
        The tensor to apply the masks to.
        
    minfo : MaskInfo
        Mask information containing size, masks, and value.
    
    axes : tuple, default: (1, 2)
        The axes corresponding to the masks, defaults to (1, 2).
    
    ndim : int, default: 4
        The number of dimensions in the tensor, defaults to 4.
    
    fmt : SliceFormat, default: 'slice'
        Format of the slices in the masks, defaults to 'slice'.
    
    val : tuple, default: (0, 0, 0)
        The value to use for the masks, defaults to (0, 0, 0).
    
    inplace : bool, default: True
        Whether to apply the masks in place, defaults to True.
    
    outsize : tuple, default: (32, 32)
        The size to resize the tensor to after applying masks, defaults to (32, 32).

    Returns
    -------
    tensor
        The masked and resized tensor.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> applymasks(torch.rand(3, 400, 400), minfo)
    # Returns the tensor with masks applied and resized.
    
    
    See Also
    --------
    applyminfo : 
        Alias for applymasks.
    
    use_mask_info : 
        Alias for applymasks.
    
    applymaskinfo : 
        Alias for applymasks.    
    
    reducemasks : 
        Apply multiple masks to a tensor and resize it.
        
    asto.chns.channels_resize : 
        Resize the tensor to a specific size adjusting channels format if needed.
    '''
    if isnone(ndim): 
        ndim = t.ndim
    
    msize, masks = minfo[SIZE], minfo[MASKS]
    
    masks = tuple(makeslcs(*slcs,  axes=axes, ndim=ndim, fmt=fmt) for slcs in masks.values())
    mtens = reducemasks(t, masks, msize=msize, axes=axes, fmt=fmt, inplace=inplace, val=val)
    return channels_resize(mtens, outsize)
    
    
@wraps(applymasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def use_mask_info(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for applymasks.''';
    return applymasks(t, minfo, axes, ndim, fmt, val, inplace, outsize)


@wraps(applymasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def applymaskinfo(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for applymasks.''';
    return applymasks(t, minfo, axes, ndim, fmt, val, inplace, outsize)


@wraps(applymasks, assigned=WRAPS_ASSIGN_ANNDOCS)
def applyminfo(
    t: tensor, 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple = (0, 0, 0), 
    inplace: bool = True, 
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for applymasks.''';
    return applymasks(t, minfo, axes, ndim, fmt, val, inplace, outsize)

# %% ../nbs/03_mskr.ipynb 24
def masktens(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''
    Apply masks from MaskInfo to a list of tensors and resize them.

    Parameters
    ----------
    tens : list
        A list of tensors to apply the masks to.
        
    minfo : MaskInfo
        Mask information containing size, masks, and value.
        
    axes : tuple, default: (1, 2)
        The axes corresponding to the masks, defaults to (1, 2).
        
    ndim : int, default: 4
        The number of dimensions in the tensors, defaults to 4.
        
    fmt : SliceFormat, optional
        Format of the slices in the masks, defaults to 'slice'.
        
    val : tuple | nan, default: torch.nan
        The value to use for the masks, defaults to NaN.
        
    inplace : bool, default: True
        Whether to apply the masks in place, defaults to True.
        
    outsize : tuple, default: (32, 32)
        The size to resize the tensors to after applying masks, defaults to (32, 32).

    Returns
    -------
    tensor
        A list of masked and resized tensors.
        
    Notes
    -----
    slice : SliceFormats
        The default representations of a python slice, i.e. 
        `(start: int, stop: int, step: int)`
        
    coord : SliceFormats
        The coordinate repesentation of a python slice i.e. 
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    __nones_ok : bool
        A sometimes optional parameter for slice utility functions.
        If `True`, the result is not corrected to prevent None values.
        i.e. `slice(0, 10, None)` would become `slice(0, 10, 1)`
                
    Definitions
    -----------
    :slice: `slice`
        The standard representation for a python slice, e.g.
        `(start: int, stop: int, step: int)` or `slice(0, 10, 2)`


    :svals: `tuple[int | None, int, int | None]`
        The integer representation for a python slice, e.g.
        `(start: int | None, stop: int, step: int | None)` or `slice(0, 10, None)`
        
    :slices: `tuple[slice | svals, ...] `
        An iterable of like representation for a python slice, e.g.
        `slice(0, 10, 2)`, `tuple(0, 10, 2)`, `tuple(0, 10, None)`, etc

    :coord: `tuple[int, ...]`
        The coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`
        
    :coords: `tuple[coord, ...]`
        An iterable of like coordinate representation for a python slice, e.g.
        `(x0, y0, ...), (x1, y1, ...), ...`

    Examples
    --------
    >>> masktens([torch.rand(3, 400, 400)], minfo)
    # Returns a list of tensors with masks applied and resized.
    
    See Also
    --------
    maskmany : Alias for masktens.
    mask_many : Alias for masktens.
    mask_tensors : Alias for masktens.
    repeatapply : Alias for masktens.
    applymasks : Apply masks from MaskInfo to a tensor and resize it.
    reducemasks : Apply multiple masks to a tensor and resize it.
    '''
    res = [applymasks(s, minfo, axes, ndim, fmt, val, inplace, outsize) for s in tens]
    return torch.stack(res)


@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_many(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)

@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def maskmany(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)

@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def mask_tensors(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)


@wraps(masktens, assigned=WRAPS_ASSIGN_ANNDOCS)
def repeatapply(
    tens: list[tensor], 
    minfo: MaskInfo, 
    axes: tuple = (1, 2), 
    ndim: int = 4, 
    fmt: SliceFormats = SLICE, 
    val: tuple | nan = torch.nan, 
    inplace: bool = True,
    outsize: tuple = (32, 32),
) -> tensor:
    '''Alias for masktens'''
    return masktens(tens, minfo, axes, ndim, fmt, val, inplace, outsize)

# %% ../nbs/03_mskr.ipynb 26
#| export
