"""
This file is generated by `openverse_api_client`, do not edit it directly.
"""

from datetime import datetime, timedelta, UTC
from typing import Any, cast, Self, Literal
import httpx


from openverse_api_client import endpoints


EXPIRY_THRESHOLD = 30


class {{ Async }}OpenverseClient:
    api_token: endpoints.POST_v1_auth_tokens_token.response | None = None 
    token_expiry: datetime | None = None
    credentials: endpoints.POST_v1_auth_tokens_token.params | None = None

    base_url: str = "https://api.openverse.engineering/"

    client: httpx.{{ Async }}Client
    _is_shared_client: bool

    def __init__(
        self,
        base_url: str | None = None,
        client_id: str | None = None,
        client_secret: str | None = None,
        httpx_client: httpx.{{ Async }}Client | None = None,
    ):
        self.base_url = base_url if base_url else self.base_url
        if self.base_url[-1] != "/":
            self.base_url += "/"
        
        if client_id or client_secret:
            assert client_id and client_secret, "`client_id` and `client_secret` are both required when either is defined"
            
            self.credentials = endpoints.POST_v1_auth_tokens_token.params(
                grant_type="client_credentials",
                client_id=client_id,
                client_secret=client_secret,
            )
        
        if httpx_client is None:
            self.client = httpx.{{ Async }}Client()
            self._is_shared_client = False
        else:
            self.client = httpx_client
            self._is_shared_client = True
    
    {{ def }} __{{ a }}enter__(self) -> Self:
        return self

    {{ def }} __{{ a }}exit__(self, exc_type=None, exc_value=None, traceback=None) -> None:
        {{ await }}self.client.__{{ a }}exit__(exc_type, exc_value, traceback)

    {{ def }} close(self):
        {{ await }}self.client.{{ a }}close()

    {{ def }} _base_request(
        self,
        method: str,
        path: str,
        params: dict,
        headers: httpx.Headers,
    ) -> httpx.Response:
        return {{ await }}self.client.request(
            method=method,
            url=f"{self.base_url}{path}",
            params=params,
            headers=headers,
        )
    
    {{ def }} _request(
        self,
        method: str,
        path: str,
        params: dict,
        headers: httpx.Headers,
    ) -> httpx.Response:
        return {{ await }}self._base_request(
            method=method,
            path=path,
            params=params,
            headers=headers.update({{ await }}self._get_auth_headers())
        )

    {{ def }} _get_auth_headers(self) -> dict:
        if self.credentials is None:
            return {}
        
        if self.api_token is None or self.token_expiry < datetime.now():
            endpoint = endpoints.POST_v1_auth_tokens_token
            token_response = {{ await }}self._base_request(
                method=endpoint.method,
                path=endpoint.endpoint,
                params=self.credentials,
            )

            {{ await }}token_response.{{ a }}read()
            self.api_token = cast(endpoint.response, token_response.json())
            self.token_expiry = datetime.now(UTC) + timedelta(seconds=self.api_token["expires_in"] - EXPIRY_THRESHOLD)
        
        return {"Authorization": f"Bearer {self.api_token['access_token']}"}
    
    {% for method in methods -%}
    {% for signature in method.signatures -%}
    {% if method.overloaded %}
    @overload
    {%- endif %}
    {{ def }} {{ method.endpoint.__name__ }}(
        self,
        {% for param in signature.parameters -%}
        {{ param.name }}: {{ param.type }}{% if param.default != _empty %} = {{ param.default }}{% endif %},
        {% endfor -%}
        headers: dict | httpx.Headers | None = None
    ) -> endpoints.{{ method.endpoint.__name__ }}.response:
        {%- if method.overloaded %}
        ...{% endif -%}
    {% endfor -%}
        {%- if method.overloaded %}
    {{ def }} {{ method.endpoint.__name__ }}(self, **kwargs):
        params = kwargs
        {%- else %}
        params = {
            {%- for param in (method.signatures | first).parameters %}
            "{{ param.name }}": {{ param.name }},
            {%- endfor %}
        }
        {%- endif %}

        path = "{{ method.endpoint.endpoint }}"

        {%- for path_param in method.endpoint.path_params %}
        path = path.replace(":{{ path_param }}", params["{{ path_param }}"])
        del params["{{ path_param }}"]
        {%- endfor %}

        headers = httpx.Headers(headers or {})
        headers.setdefault("content-type", "{{ method.endpoint.content_type }}")

        response = {{ await }}self._request(
            method="{{ method.endpoint.method }}",
            path=path,
            params=params,
            headers=headers,
        )

        {{ await }}response.{{ a }}read()
        {% if method.endpoint.response() is mapping -%}
        content = response.json()
        {% else -%}
        content = response.content
        {% endif -%}
        return cast(endpoints.{{ method.endpoint.__name__ }}.response, content)
    {% endfor -%}
