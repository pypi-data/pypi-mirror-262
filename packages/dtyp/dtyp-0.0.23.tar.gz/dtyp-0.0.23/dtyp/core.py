# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['T', 'K', 'P', 'isnone', 'notnone', 'istype', 'isdict', 'isparam', 'isvarg', 'isvkws', 'issig', 'ispsa', 'ispsk',
           'hasvarg', 'hasvkws', 'isoptional', 'getopt', 'init_enum', 'getname', 'private', 'mangled', 'unmangle',
           'unmangled_annotations', 'in_lookup', 'adjust_var_position', 'put_var_in_signature',
           'wrapper_signature_update', 'signature_from_annotations', 'typed_dict_signature', 'typed_dict_defaults',
           'typed_dict_func', 'get_typed_dict_keywords', 'typedict', 'dtyp', 'typekwds', 'tdict', 'new', 'setkeywords']

# %% ../nbs/01_core.ipynb 6
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind
from functools import wraps, partial
from enum import EnumMeta

# %% ../nbs/01_core.ipynb 8
from types import NoneType, WrapperDescriptorType, FunctionType, MethodWrapperType
from typing import (
    Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict, Literal,
    ParamSpecArgs, ParamSpecKwargs, get_args, get_origin, _UnionGenericAlias
)

# %% ../nbs/01_core.ipynb 10
#| export


# %% ../nbs/01_core.ipynb 12
#| export


# %% ../nbs/01_core.ipynb 14
#| export


# %% ../nbs/01_core.ipynb 16
U1 = '_'
U2 = '__'

DCT = 'dct'
NON = 'non'
SIG = 'sig'
RETURN = 'return'
SUBCLASS = 'subclass'

ARGS = 'args'
KWARGS = 'kwargs'

__DOC__ = '__doc__'
__NAME__ = '__name__'
__MODULE__ = '__module__'
__QUALNAME__ = '__qualname__'

__DCT = f'{U2}{DCT}'
__NON = f'{U2}{NON}'
__SIG = f'{U2}{SIG}'
__SUBCLASS = f'{U2}{SUBCLASS}'
__FORCE_DEFAULTS = f'{U2}force_defaults'

# %% ../nbs/01_core.ipynb 18
# NOTE: T = TypeVar('T', bound=TypedDict) is not valid since TypedDict is not a class
T = TypeVar('T', bound=dict)

K = TypeVar('K', bound=dict) 

P = ParamSpec('P')

# %% ../nbs/01_core.ipynb 19
_ARGS = Parameter('args', kind=ParamKind.VAR_POSITIONAL, annotation=P.args)
'''Default `Parameter` for `*args`.''';

_KWDS = Parameter('kwargs', kind=ParamKind.VAR_KEYWORD, annotation=P.kwargs)
'''Default `Parameter` for `**kwargs`.''';

# %% ../nbs/01_core.ipynb 21
def isnone(x) -> TypeGuard[None]:
    '''Check if `x` is `None`'''
    return x is None

def notnone(x) -> TypeGuard[Any]:
    '''Check if `x` is not `None`'''
    return not isnone(x)

def istype(x) -> TypeGuard[type]:
    '''Check if `x` is a `type`'''
    return isinstance(x, type)

def isdict(x) -> TypeGuard[dict]:
    '''Check if `x` is a `dict`'''
    return isinstance(x, dict)

def isparam(x) -> TypeGuard[Parameter]:
    '''Check if `x` is a `Parameter`'''
    return isinstance(x, Parameter)

def isvarg(x) -> TypeGuard[Parameter.VAR_POSITIONAL]:
    '''Check if `x` is a parameter of `Parameter.VAR_POSITIONAL` kind.'''
    return isparam(x) and x.kind == Parameter.VAR_POSITIONAL

def isvkws(x) -> TypeGuard[Parameter.VAR_KEYWORD]:
    '''Check if `x` is a parameter of `Parameter.VAR_KEYWORD` kind.'''
    return isparam(x) and x.kind == Parameter.VAR_KEYWORD

def issig(x) -> TypeGuard[Signature]:
    '''Check if `x` is a `Signature`'''
    return isinstance(x, Signature)

def ispsa(x) -> TypeGuard[ParamSpecArgs]:
    '''Check if `x` is an instance of `ParamSpecArgs` i.e. `P.args`'''
    return isinstance(x, ParamSpecArgs)

def ispsk(x) -> TypeGuard[ParamSpecKwargs]:
    '''Check if `x` is an instance of `ParamSpecKwargs` i.e. `P.kwargs`'''
    return isinstance(x, ParamSpecKwargs)

# %% ../nbs/01_core.ipynb 22
def hasvarg(spec: Signature | dict[str, Parameter]) -> bool:
    '''Check if the signature has a VAR_POSITIONAL parameter.'''
    if issig(spec): return any((isvarg(p) for p in spec.parameters.values()))
    if isdict(spec): return any((isvarg(p) for p in spec.values()))
    return any((isvarg(p) for p in spec))

def hasvkws(spec: Signature | dict[str, Parameter]) -> bool:
    '''Check if the signature has a VAR_KEYWORD parameter.'''
    if issig(spec): return any((isvkws(p) for p in spec.parameters.values()))
    if isdict(spec): return any((isvkws(p) for p in spec.values()))
    return any((isvkws(p) for p in spec))

# %% ../nbs/01_core.ipynb 23
def isoptional(x) -> TypeGuard[T | None]:
    "Check if `x` is an optional type"
    isname = getattr(x, __NAME__, None) == 'Optional'
    isgenr = isinstance(x, _UnionGenericAlias)
    args = get_args(x)
    isnone = False if not len(args) else args[-1] == NoneType
    return isname and isgenr and isnone

def getopt(x, i: int = 0):
    "Check if `x` is an optional type"
    if not isoptional(x): return None
    args = get_args(x)
    if len(args) == 0: return None
    return args[i if i < len(args) else -1] 

# %% ../nbs/01_core.ipynb 25
def init_enum(ecls: EnumMeta) -> EnumMeta | None:
    try: return ecls()
    except: ...
    try: return ecls._default_() if callable(ecls._default_) else ecls._default_
    except: ...
    try: return ecls._missing_(None)
    except: ...
    try: list(ecls.__members__.values())[0]
    except: ...
    try: return ecls(0)
    except: ...
    return None

# %% ../nbs/01_core.ipynb 28
def getname(obj) -> str:
    return getattr(obj, __NAME__, getattr(obj, __QUALNAME__, str(obj)))

def private(attr: str) -> str:
    return f'{U1}{attr.lstrip(U1)}'

def mangled(cls: object, attr: str) -> str:
    return f'{private(getname(cls))}{U2}{attr.lstrip(U2)}'

def unmangle(cls: object, attr: str) -> str:
    return attr.split(private(getname(cls)))[-1]

# %% ../nbs/01_core.ipynb 30
def unmangled_annotations(cls: T) -> dict:
    return {unmangle(cls, k): v for k, v in get_annotations(cls).items()}

# %% ../nbs/01_core.ipynb 31
def in_lookup(key: str, ann: T, lookup: dict = {}) -> tuple[T, bool]:
    val = lookup.get(key, None)
    
    # handle ambigious bool values
    try: flag = bool(val)
    except: flag = False
    
    if notnone(val) and flag == True: 
        return val, flag
    
    for use in (val, ann):
        # check if val / ann in keys
        if not flag:
            try: 
                if use in lookup: return lookup.get(use), True
            except: ...
            
        # check if val / ann in values
        if not flag:
            try: 
                vals = list(lookup.values() if isdict(lookup) else lookup)
                if use in vals: return vals[vals.index(use)], True
            except: ...
            
    # check if anns in an instance of flag
    if not flag:
        try: 
            if ann == val: return val, True
        except: ...
        
    # check if val / ann in an instance of val
    if not flag:
        try: 
            if isinstance(ann, val): return val, True
        except: ...
            
    return val, flag

# %% ../nbs/01_core.ipynb 34
def adjust_var_position(
    __parameters: dict[str, Parameter] | list[Parameter],
) -> list[Parameter]:
    prms = list(__parameters.values()) if isdict(__parameters) else __parameters
    vidx = -1
    pidx = -1
    if hasvarg(prms):
        for i, p in enumerate(prms):
            if p.kind in {ParamKind.POSITIONAL_ONLY, ParamKind.POSITIONAL_OR_KEYWORD, }:
                pidx = i
                continue
            
            if p.kind == ParamKind.VAR_POSITIONAL:
                vidx = i
            
        if vidx < 0: 
            return prms
        
        if vidx < pidx:
            prms.insert(pidx, prms.pop(vidx))
            return prms
        
    return prms

# %% ../nbs/01_core.ipynb 35
def put_var_in_signature(
    __signature: Signature,
    __varpos: bool = True,
    __varkws: bool = True,
) -> Signature:
    sig = __signature
    prms = list(sig.parameters.values())
    ret = sig.return_annotation
    names = set()
    if not hasvarg(sig) and __varpos:
        for i, p in enumerate(prms):
            names.add(p.name)
            if p.kind in {ParamKind.POSITIONAL_ONLY, ParamKind.POSITIONAL_OR_KEYWORD}:
                continue
            break
        
        vargs = _ARGS.replace()
        if vargs.name in names: vargs = vargs.replace(name='__variadic_arguments')
        prms.insert(i + 1, vargs)
        sig = Signature(prms, return_annotation=ret)
        
    if not hasvkws(sig) and __varkws: 
        prms += [_KWDS, ]
        sig = Signature(prms, return_annotation=ret)
    return sig

# %% ../nbs/01_core.ipynb 38
def wrapper_signature_update(
    wrapper: WrapperDescriptorType | FunctionType | MethodWrapperType, 
    __signature: Signature, 
    __callable: T
) -> WrapperDescriptorType:
    wrapper.__signature__ = __signature
    wrapper.__annotations__ = __callable.__annotations__
    try: 
        wrapper.__doc__  = __callable.__doc__
        wrapper.__call__ = __callable.__doc__
        wrapper.__init__.__signature__ = __signature
        wrapper.__init__.__annotations__ = __callable.__annotations__
        wrapper.__annotations__ = __callable.__annotations__
    except: pass
    return wrapper

# %% ../nbs/01_core.ipynb 40
def signature_from_annotations(
    __dct: T,
    *, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return_annot: type | None = None,
    __rescue_values: dict | None = dict(),
    __ignore_values: dict | None = dict(),
    __use_optionals: bool = True,
    **kwargs: P.kwargs
) -> Signature:
    '''Generate a function signature based on annotations and optionally specified defaults.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    __use_optionals : bool, default: True
        Whether or not to include optional parameters in the signature.
        
    **kwargs : P.kwargs
        Additional options to control the signature generation. These can include
        specific default values for some or all of the annotated parameters.
    
    Returns
    -------
    Signature
        A `Signature` object representing the generated signature for the function.
        
    See Also
    --------
    sigr.signature_from_annotations : Generate a function signature based on annotations.
    '''
    __return = kwargs.get('__return_annot', __return_annot)
    __ignore = kwargs.get('__ignore_values', __ignore_values or {})
    __rescue = kwargs.get('__rescue_values', __rescue_values or {})
    __useopt = kwargs.get('__use_optionals', __use_optionals)
    if not isdict(__ignore): {getattr(v, __NAME__, v): v for v in __ignore}
    if not isdict(__ignore): {getattr(v, __NAME__, v): v for v in __ignore}
    
    __force_defaults = kwargs.get('__force_defaults', __force_defaults)
    
    anns = get_annotations(__dct)
    return_annotation = __return or anns.pop(RETURN, __return if notnone(__return) else None)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        opt = getopt(ann)
        isopt = isoptional(ann)
        useopt = isopt and __useopt
        isenum = isinstance(opt if useopt else ann, EnumMeta)
        
        val = kwargs.get(kwd, None)
        err = False
        
        typ = opt if useopt else ann
        ign, ignore_ok = in_lookup(kwd, typ, __ignore)
        res, rescue_ok = in_lookup(kwd, typ, __rescue)
        # print(
        #     'kwd', kwd, 
        #     'ann', ann, 
        #     'opt', opt, 
        #     'typ', typ,
        #     'ignore', ign, 
        #     'ign_ok', iok, 
        #     'rescue', res, 
        #     'res_ok', rok
        # )
        
        if isnone(val) and (istype(ann) or isopt) and not ignore_ok:
            try: # try to instantiate the annotation 
                val = ann()
            except: # if it fails, set the default value to None
                err = True
                val = None
                
            if useopt: # Optional paramter, use the first not None type to try and initalize an default value
                try: # try to instantiate the annotation 
                    err = False
                    val = opt()
                except: # if it fails, set the default value to None
                    err = True
                    val = None
                    
            # Maybe we failed gracefully, but that was because we were working with
            # an enum type, so try a special init stragety
            if isenum and isnone(val): 
                try:
                    err = False 
                    val = init_enum(opt if isopt else ann)
                except: 
                    err = True
                    val = None
        
        
        if rescue_ok and isnone(val):
            val = res
        
        pkind = Parameter.POSITIONAL_OR_KEYWORD
        
        # variadic_args need `P.args` like type annotation to get here
        if kwd == ARGS and __varpos and (ispsa(ann) or isnone(ann)): 
            pkind = Parameter.VAR_POSITIONAL
            
        # variadic_kwargs need `P.kwargs` like type annotation to get here
        if kwd == KWARGS and __varkws and (ispsk(ann) or isnone(ann)): 
            pkind = Parameter.VAR_KEYWORD
        
        prm = Parameter(kwd, kind=pkind, annotation=ann)
        if (            
            (
                notnone(val) or  # we have a default value
                not err or       # there was no error in trying to initiate the annotation
                __force_defaults # we are going to force the default value
            ) and not (
                pkind in (Parameter.VAR_POSITIONAL,) # can't have defaults
            )
        ): 
            prm = prm.replace(default=val)
        prms.append(prm)

    prms = adjust_var_position(prms)
    sig = Signature(prms, return_annotation=return_annotation)
    return put_var_in_signature(sig, __varpos, __varkws)

# %% ../nbs/01_core.ipynb 48
def typed_dict_signature(__dct: T, **kwargs: K) -> Signature:
    '''Generates a Signature object representing the signature of a TypedDict.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the signature is generated
        .
    **kwargs : TypedDict
        Default values for the TypedDict fields, if any.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, default: `__dct`
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.

    Returns
    -------
    Signature
        A Signature object representing the TypedDict's field names, types, and default values.
    '''
    kwargs.update(__return_annot=__dct)
    return signature_from_annotations(__dct=__dct, **kwargs)

# %% ../nbs/01_core.ipynb 51
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    **kwargs: K
) -> T:
    '''Creates an instance of a TypedDict with default values specified either in the 
    signature or as keyword arguments.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the instance is created.
        
    __sig : Signature, optional
        A predefined Signature object for the TypedDict, if available.
        
    __non : bool, default: True
        If True, non-specified fields will be included with `None` values.
        
    **kwargs : TypedDict
        Overrides for default values specified in the signature.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.

    Returns
    -------
    T
        An instance of the TypedDict with default values set.
    '''
    sig = __sig or typed_dict_signature(__dct, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Parameter.empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

# %% ../nbs/01_core.ipynb 53
def typed_dict_func(
    __dct: T, 
    __sig: Signature | None = None,
    __non: bool = True, 
) -> Callable[[T, Signature], Callable[P, T]]:
    '''Returns a partial function for creating TypedDict instances with defaults 
    and potentially non-values excluded.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which instances will be created.
        
    __sig : Signature, optional
        The signature to use for the TypedDict. If not provided, it will be generated.
        
    __non : bool, default: True
        Determines whether non-values (None) should be included in the output.
        
    Other Parameters
    ----------------
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.

    Returns
    -------
    Callable
        A partial function that can be used to create instances of the TypedDict.
    '''
    return partial(typed_dict_defaults, __dct, __sig=__sig, __non=__non)

# %% ../nbs/01_core.ipynb 57
def get_typed_dict_keywords(
    __dct: T, 
    __pop_keyword: bool = True, 
    __defaults: T | None = None, 
    **kwargs: K
) -> T:
    '''Get the keywords arguments as specified in a `TypedDict`.
    
    Parameters
    ----------
    __pop_keyword : bool, default: True
        Whether to remove the keyword from the `kwargs` dictionary, by default True
        
    __defaults : T, optional
        The default values for the `TypedDict`, by default None
        
    kwargs : dict
        The keyword arguments to be added to the `TypedDict`
        
    Returns
    -------
    T
        The `TypedDict` with the keyword arguments added
    '''
    kwds = __defaults or {}
    anns = get_annotations(__dct)
    # unmangled annotation names
    unmg = unmangled_annotations(__dct)
    keys = list(kwargs.keys())
    for key in keys:
        mkw = mangled(__dct, key) # mangled keyword name
        if (
            key in unmg or # key is in the unmangled keywords
            key in anns or # key is a mangled keyword
            mkw in anns # if the mangled keyword is in the annotations
        ): 
            ukw = unmangle(__dct, key)    # unmangled the keyword name
            kwds[ukw] = kwargs.get(key) # add the unmangled keyword and its value to the result
            if __pop_keyword:  kwargs.pop(key, None)
            continue
    return kwds

# %% ../nbs/01_core.ipynb 59
def prune_type_dict_keywords(__dct: T, **kwargs) -> T:
    keys = set()
    anns = get_annotations(__dct)
    unmg = unmangled_annotations(__dct)
    for key in kwargs:
        mkw = mangled(__dct, key)
        if (key in unmg or key in anns or mkw in anns): 
            keys.add(key)
    return dict(((k, v) for k, v in kwargs.items() if k not in keys))

# %% ../nbs/01_core.ipynb 61
class typedict(dict):
    '''A base class for creating TypedDict instances with default values and custom behaviors.

    Subclasses can specify TypedDict types and default values for their fields.
    '''
    def __init_subclass__(cls: Type[Self], **defs: K) -> None:
        '''
        Initializes a subclass with specified TypedDict defaults 
        and optional custom signature.

        Parameters
        ----------
        **defs : TypedDict
            Defaults and TypedDict specifications for the subclass.
            
        Other Parameters
        ----------------
        __force_defaults : bool, default: False
            Whether or not to force defaults, which includes setting `None` 
            for optional parameters.
            
        __varpos: bool, default: True
            Whether or not to include `*args` if not found in the annotations.

        __varkws: bool: default True
            Whether or not to include `**kwargs` if not found in the annotations.
            
        __return_annot: type, optional
            The type for the return value, which might not be specified in the 
            extracted annotaitons.
            
        __rescue_values: dict, optional
            The type or default value ot use if the attempt to initiate a default
            value from the type annotation fails.
            
        __ignore_values: dict, optional
            The parameter name or types to ignore when attempting to initiate a
            default value from the type annotation.

        Raises
        ------
        KeyError
            If __dct is not provided in the subclass definition.
        '''
        super().__init_subclass__()
        sub = defs.pop('__subclass', False)
        typ = getattr(cls, '__dct', None)
        try:
            cls.__dct = defs.pop('__dct', typ)
            if isnone(cls.__dct): raise KeyError('__dct')
            cls.__non = defs.pop('__non', True)
            cls.__sig = defs.pop('__sig', typed_dict_signature(cls.__dct, **defs))
            
        except (KeyError, AttributeError) as err:
            if not sub: 
                raise err
        return
    
    def __init__(self: Self, *args: P.args, **kwargs: P.kwargs):
        '''Initializes an instance of the subclass with default values 
        and optional overrides.

        Parameters
        ----------
        *args
            Unused, present to comply with the dict interface.
            
        **kwargs
            Field values that override the defaults specified in the subclass.
        '''
        kwargs.pop('__dct', None)
        kwargs.pop('__sig', None)
        __non = kwargs.pop('__non', True)
        kwds = typed_dict_defaults(type(self).__dct, __sig=type(self).__sig, __non=__non, **kwargs)
        super().__init__(*args, **kwds)
        
    def __instancecheck__(self, __instance) -> bool:
        '''Checks if the instance is of the TypedDict type specified in the subclass.

        Parameters
        ----------
        __instance
            The instance to check.

        Returns
        -------
        bool
            True if the instance is of the correct TypedDict type, False otherwise.
        '''
        return super().__instancecheck__(__instance) or isinstance(__instance, type(self).__dct)
    
    def dropnones(self: Self, inplace: bool = True) -> Self:
        '''Removes keys with `None` values from the TypedDict instance.

        Parameters
        ----------
        inplace : bool, default: True
            If True, modifies the instance in place; otherwise, 
            returns a new instance without `None` values.

        Returns
        -------
        Self
            The instance itself if inplace is True, otherwise a new instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def filter(cls: Type[Self], __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.

        Parameters
        ----------
        __defaults : T, optional
            The default values for the `TypedDict`, by default None
            
        kwargs : dict
            The keyword arguments to be added to the `TypedDict`
            
        Returns
        -------
        Self
            An instance of the `TypedDict` with the keyword arguments added
        '''
        return get_typed_dict_keywords(cls.__dct, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls: Type[Self], **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        return prune_type_dict_keywords(cls.__dct, **kwargs)
        return cls(prune_type_dict_keywords(cls.__dct, **kwargs))

# %% ../nbs/01_core.ipynb 63
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class dtyp(typedict, __subclass=True): 
    ...
    
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class typekwds(typedict, __subclass=True): 
    ...
    
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class tdict(typedict, __subclass=True): 
    ...

# %% ../nbs/01_core.ipynb 68
def new(d: T, **kwargs: K):
    '''A decorator for creating new typedict subclasses from a 
    TypedDict definition with specified defaults.

    Parameters
    ----------
    d : TypedDict
        The TypedDict definition to base the subclass on.
    
    __force_defaults : bool, default: False
        Whether or not to force defaults, which includes setting `None` 
        for optional parameters.
        
    __varpos: bool, default: True
        Whether or not to include `*args` if not found in the annotations.

    __varkws: bool: default True
        Whether or not to include `**kwargs` if not found in the annotations.
        
    __return_annot: type, optional
        The type for the return value, which might not be specified in the 
        extracted annotaitons.
        
    __rescue_values: dict, optional
        The type or default value ot use if the attempt to initiate a default
        value from the type annotation fails.
        
    __ignore_values: dict, optional
        The parameter name or types to ignore when attempting to initiate a
        default value from the type annotation.
        
    **kwargs : TypedDict
        Default values for the TypedDict fields.

    Returns
    -------
    Callable
        A decorator that when applied to a class, modifies it to be a typedict subclass.
    '''
    
    def decorator(func: Callable):
        '''A decorator for functions to automatically fill in TypedDict 
        based on its signature and provided defaults.

        Parameters
        ----------
        d : TypedDict
            The TypedDict definition to base the argument filling on.
        **kwargs : TypedDict
            Default values for the TypedDict fields.

        Returns
        -------
        Callable
            A decorator that when applied to a function, wraps it so that its keyword 
            arguments are filled in based on the TypedDict and defaults.
        '''
        __non = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        
        @wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
        class wrapper(typedict, __dct=d, __sig=signature, __non=__non, __subclass=True):
            ...
        wrapper.__signature__ = signature
        wrapper = wrapper_signature_update(wrapper, signature, d)
        return wrapper
    
    return decorator

# %% ../nbs/01_core.ipynb 72
def setkeywords(d: T, **kwargs: K):
    
    def decorator(func: Callable):
        dropnones = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        construct = typed_dict_func(d, signature, dropnones)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__))
        def wrapper(**kwargs: Type[d]) -> Type[d]:
            kwds = construct(**kwargs)
            return d(**kwds)
        wrapper.__signature__ = signature
        wrapper = wrapper_signature_update(wrapper, signature, d)
        return wrapper
    
    return decorator
