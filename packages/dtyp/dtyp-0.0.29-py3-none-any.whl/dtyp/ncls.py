# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_ncls.ipynb.

# %% auto 0
__all__ = ['TypedDictMeta', 'TypeDict', 'dtyp', 'typedict', 'tdict', 'tkws', 'TypeKwds', 'typekwds', 'new']

# %% ../nbs/10_ncls.ipynb 6
from functools import wraps, partial

# %% ../nbs/10_ncls.ipynb 8
from typing import (Self, Callable, TypedDict, get_type_hints, _TypedDictMeta)

# %% ../nbs/10_ncls.ipynb 10
#| export


# %% ../nbs/10_ncls.ipynb 12
#| export


# %% ../nbs/10_ncls.ipynb 14
from .cons import (__DOC__, __NEW__, __MODULE__, __DEFAULTS__, __TYPEDICT__, __ANNOTATIONS__, __NAME__, __QUALNAME__)
from .atyp import T, P, K
from .grds import isnone, notnone, isdunder, ismangled, istypeddictmeta
from .util import getname, wrapper_signature_update, _get_class_keys
from .sigs import typed_dict_signature
from .tdct import (typed_dict_defaults, get_typed_dict_keywords, prune_type_dict_keywords)

# %% ../nbs/10_ncls.ipynb 16
def _totypeddict(cls: Callable, td: _TypedDictMeta | None = None, name: str | None = '') -> _TypedDictMeta:
    if isnone(td):
        if isnone(name) and notnone(td): name = getname(td)
        return TypedDict( f'{name}_typeddict', get_type_hints(cls))
    return td

# %% ../nbs/10_ncls.ipynb 18
class TypedDictMeta(type):
    __typedict__: dict
    '''The `TypedDict` created when subclassed''';
    
    __defaults__: dict = dict()
    '''Default values for the `TypeDict`''';
    
    def __instancecheck__(cls, instance):
        if not isinstance(instance, dict): return False
        given = get_type_hints(cls)
        found = {k: type(v) for k, v in instance.items()}
        # Simplified type checking logic
        return all(given.get(k) == found.get(k) for k in given)
    
    def __new__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        new = super().__new__(cls, name, bases, namespace)
        return new
    
    def __defs__(cls, **kwargs: P.kwargs) -> dict:
        # print('__defs__', kwargs)
        anns = get_type_hints(cls)
        sign = typed_dict_signature(cls.__typedict__, **kwargs)
        base = typed_dict_defaults(cls.__typedict__, __sig=sign, **kwargs)
        
        defs = cls() if issubclass(cls, dict) else dict()
        defs |= typed_dict_defaults(cls, )
        base.update({k: v for k, v in cls.__dict__.items() if k in anns})
        base.update({k: v for k, v in kwargs.items() if (k in set(list(base) + list(defs)))})
        base.update(defs)
        return base
    
    def __init__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        super().__init__(cls, name, bases)
        
        dget = lambda d: dict.get(d, __TYPEDICT__, None)
        for _dct in (namespace, kwargs):
            if notnone(tdct := dget(_dct)): break
        tdct = _totypeddict(cls, tdct)
        sign = typed_dict_signature(tdct, **kwargs)
        namespace.setdefault(__ANNOTATIONS__, get_type_hints(tdct))
        namespace.setdefault('__signature__', sign)
        
        setattr(cls, __TYPEDICT__, tdct)
        setattr(cls, '__signature__', sign)
        defs = cls.__defs__(**kwargs)
        setattr(cls, __DEFAULTS__, defs)

# %% ../nbs/10_ncls.ipynb 20
class TypeDict(dict, metaclass=TypedDictMeta):
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__()
        # print('__sub__', cls, args, kwargs)

    def __new__(cls, *args: P.args, **kwargs: P.kwargs):
        newdct = super().__new__(cls, *args, **kwargs)
        joined = {**cls.__defaults__, **kwargs}
        newdct.update(joined)
        return newdct
    
    def __init__(self, *args, **kwargs):
        tdct = self.__typedict__
        sign = self.__signature__
        kwds = typed_dict_defaults(tdct, __sig=sign, **kwargs)
        super().__init__(*args, **kwds)
    
    def dropnones(self, inplace: bool = True):
        '''Removes keys with `None` values from the TypedDict instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def filter(cls, __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return get_typed_dict_keywords(tdict, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls, **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return prune_type_dict_keywords(tdict, **kwargs)

# %% ../nbs/10_ncls.ipynb 21
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class dtyp(TypeDict, __subclass=True):  ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typedict(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tdict(TypeDict, __subclass=True): ...
    

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tkws(TypeDict, __subclass=True): ...
    
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class TypeKwds(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typekwds(TypeDict, __subclass=True): ...

# %% ../nbs/10_ncls.ipynb 30
def _inherit_annots(cls: Callable | _TypedDictMeta, kls: Callable, **kwargs) -> dict:
    inval = dict((k, v) for k  in _get_class_keys(kls) if notnone(v := getattr(kls, k, None)))
    inval = {**getattr(cls, __ANNOTATIONS__, dict()), **inval}
    inval.update(kwargs)
    if istypeddictmeta(cls): 
        inval.update(__typedict__=cls)
    return inval
    
def _untype_dict(tdct: _TypedDictMeta, **kwargs) -> 'TypeDict':
    if not istypeddictmeta(tdct): return tdct
    anns = get_type_hints(tdct)
    udct = type(
        f'{getname(tdct)}_untyped', 
        (TypeDict, ), 
        dict(__annotations__=anns, __typedict__=tdct,), 
        **{**kwargs, **anns}, 
    )
    return udct

# %% ../nbs/10_ncls.ipynb 31
def new(d: T, **kwargs: K):
    def decorator(func: Callable):
        signature = typed_dict_signature(d, **kwargs)
        # print(signature)
        inval = _inherit_annots(d, func, **kwargs)
        undct = _untype_dict(d, **kwargs)
                
        bases = getattr(d, '__bases__', ())
        bases = tuple(b for b in bases if not issubclass(b, TypeDict))
        bases = bases + (TypeDict, )
        
        # print(kwargs, inval)
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
        class subdict(undct, **inval): ...
        subdict.__signature__ = signature
        subdict = wrapper_signature_update(subdict, signature, d, False)
        return subdict
    
    return decorator
