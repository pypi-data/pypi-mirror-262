# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_core.ipynb.

# %% auto 0
__all__ = ['T', 'K', 'P', 'isnone', 'notnone', 'istype', 'isparam', 'isvarg', 'isvkws', 'hasvarg', 'hasvkws', 'getname',
           'private', 'mangled', 'unmangle', 'unmangled_annotations', 'put_var_in_signature',
           'signature_from_annotations', 'typed_dict_signature', 'typed_dict_defaults', 'typed_dict_func',
           'get_typed_dict_keywords', 'typedict', 'dtyp', 'typekwds', 'tdict', 'new', 'setkeywords']

# %% ../nbs/01_core.ipynb 6
from inspect import Signature, Parameter, get_annotations, _ParameterKind as ParamKind
from functools import wraps, partial

# %% ../nbs/01_core.ipynb 8
from typing import Any, Self, Type, Callable, TypeVar, ParamSpec, TypeGuard, TypedDict

# %% ../nbs/01_core.ipynb 10
#| export


# %% ../nbs/01_core.ipynb 12
#| export


# %% ../nbs/01_core.ipynb 14
#| export


# %% ../nbs/01_core.ipynb 16
U1 = '_'
U2 = '__'

DCT = 'dct'
NON = 'non'
SIG = 'sig'
RETURN = 'return'
SUBCLASS = 'subclass'

ARGS = 'args'
KWARGS = 'kwargs'

__DOC__ = '__doc__'
__NAME__ = '__name__'
__MODULE__ = '__module__'
__QUALNAME__ = '__qualname__'

__DCT = f'{U2}{DCT}'
__NON = f'{U2}{NON}'
__SIG = f'{U2}{SIG}'
__SUBCLASS = f'{U2}{SUBCLASS}'
__FORCE_DEFAULTS = f'{U2}force_defaults'

# %% ../nbs/01_core.ipynb 18
# NOTE: T = TypeVar('T', bound=TypedDict) is not valid since TypedDict is not a class
T = TypeVar('T', bound=dict)

K = TypeVar('K', bound=dict) 

P = ParamSpec('P')

# %% ../nbs/01_core.ipynb 19
_ARGS = Parameter('args', kind=ParamKind.VAR_POSITIONAL, annotation=P.args)
'''Default `Parameter` for `*args`.''';

_KWDS = Parameter('kwargs', kind=ParamKind.VAR_KEYWORD, annotation=P.kwargs)
'''Default `Parameter` for `**kwargs`.''';

# %% ../nbs/01_core.ipynb 21
def isnone(x) -> TypeGuard[None]:
    '''Check if `x` is `None`'''
    return x is None

def notnone(x) -> TypeGuard[Any]:
    '''Check if `x` is not `None`'''
    return not isnone(x)

def istype(x) -> TypeGuard[type]:
    '''Check if `x` is a `type`'''
    return isinstance(x, type)

def isparam(x) -> TypeGuard[Parameter]:
    '''Check if `x` is a `Parameter`'''
    return isinstance(x, Parameter)

def isvarg(x) -> TypeGuard[Parameter.VAR_POSITIONAL]:
    '''Check if `x` is a parameter of `Parameter.VAR_POSITIONAL` kind.'''
    return isparam(x) and x.kind == Parameter.VAR_POSITIONAL

def isvkws(x) -> TypeGuard[Parameter.VAR_KEYWORD]:
    '''Check if `x` is a parameter of `Parameter.VAR_KEYWORD` kind.'''
    return isparam(x) and x.kind == Parameter.VAR_KEYWORD

# %% ../nbs/01_core.ipynb 22
def hasvarg(sig: Signature) -> bool:
    '''Check if the signature has a VAR_POSITIONAL parameter.'''
    return any((isvarg(p) for p in sig.parameters.values()))

def hasvkws(sig: Signature) -> bool:
    '''Check if the signature has a VAR_KEYWORD parameter.'''
    return any((isvkws(p) for p in sig.parameters.values()))

# %% ../nbs/01_core.ipynb 25
def getname(obj) -> str:
    return getattr(obj, __NAME__, getattr(obj, __QUALNAME__, str(obj)))

def private(attr: str) -> str:
    return f'{U1}{attr.lstrip(U1)}'

def mangled(cls: object, attr: str) -> str:
    return f'{private(getname(cls))}{U2}{attr.lstrip(U2)}'

def unmangle(cls: object, attr: str) -> str:
    return attr.split(private(getname(cls)))[-1]

# %% ../nbs/01_core.ipynb 27
def unmangled_annotations(cls: T) -> dict:
    return {unmangle(cls, k): v for k, v in get_annotations(cls).items()}

# %% ../nbs/01_core.ipynb 29
def put_var_in_signature(
    __signature: Signature,
    __varpos: bool = True,
    __varkws: bool = True,
) -> Signature:
    sig = __signature
    prms = list(sig.parameters.values())
    ret = sig.return_annotation
    if not hasvarg(sig) and __varpos:
        for i, p in enumerate(prms):
            if p.kind in {ParamKind.POSITIONAL_ONLY, ParamKind.POSITIONAL_OR_KEYWORD}:
                continue
            break
        prms.insert(i + 1, _ARGS)
        # prms = [_ARGS, ] + prms
        sig = Signature(prms, return_annotation=ret)
    
    if not hasvkws(sig) and __varkws: 
        prms += [_KWDS, ]
        sig = Signature(prms, return_annotation=ret)
    return sig

# %% ../nbs/01_core.ipynb 32
def signature_from_annotations(
    __dct: T,
    *, 
    __force_defaults: bool = False, 
    __varpos: bool = True,
    __varkws: bool = True,
    __return: type | None = None ,
    **kwargs: P.kwargs
) -> Signature:
    '''Generate a function signature based on annotations and optionally specified defaults.
    
    Parameters
    ----------
    fn : Callable
        The function to analyze.
        
    __force_defaults : bool, default: False
        If True, forces the use of default values for all parameters, by default False.
        
    **kwargs : P.kwargs
        Additional options to control the signature generation. These can include
        specific default values for some or all of the annotated parameters.
    
    Returns
    -------
    Signature
        A `Signature` object representing the generated signature for the function.
        
    See Also
    --------
    sigr.signature_from_annotations : Generate a function signature based on annotations.
    '''
    __return = kwargs.get('__return', __return)
    __force_defaults = kwargs.get('__force_defaults', __force_defaults)
    anns = get_annotations(__dct)
    return_annotation = __return or anns.pop(RETURN, __return if notnone(__return) else None)
    kwds, prms = list(anns.keys()), list()
    
    for kwd, ann in zip(kwds, anns.values()):
        val = kwargs.get(kwd, None)
        err = False
        if isnone(val) and istype(ann):
            try: # try to instantiate the annotation 
                val = ann()
            except: # if it fails, set the default value to None
                err = True
                val = None


        pkind = Parameter.POSITIONAL_OR_KEYWORD                
        if kwd == ARGS and __varpos: pkind = Parameter.VAR_POSITIONAL
        if kwd == KWARGS and __varkws: pkind = Parameter.VAR_KEYWORD
        
        prm = Parameter(kwd, kind=pkind, annotation=ann)
        if notnone(val) or not err or __force_defaults: 
            prm = prm.replace(default=val)
        prms.append(prm)

    sig = Signature(prms, return_annotation=return_annotation)
    return put_var_in_signature(sig, __varpos, __varkws)

# %% ../nbs/01_core.ipynb 36
def typed_dict_signature(__dct: T, **kwargs: K) -> Signature:
    '''Generates a Signature object representing the signature of a TypedDict.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the signature is generated.
    **kwargs : TypedDict
        Default values for the TypedDict fields, if any.

    Returns
    -------
    Signature
        A Signature object representing the TypedDict's field names, types, and default values.
    '''
    return signature_from_annotations(__dct=__dct, __return=__dct, **kwargs)

# %% ../nbs/01_core.ipynb 39
def typed_dict_defaults(
    __dct: T, *, 
    __sig: Signature | None = None, 
    __non: bool = True, 
    **kwargs: K
) -> T:
    '''Creates an instance of a TypedDict with default values specified either in the 
    signature or as keyword arguments.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which the instance is created.
        
    __sig : Signature, optional
        A predefined Signature object for the TypedDict, if available.
        
    __non : bool, default: True
        If True, non-specified fields will be included with `None` values.
        
    **kwargs : TypedDict
        Overrides for default values specified in the signature.

    Returns
    -------
    T
        An instance of the TypedDict with default values set.
    '''
    sig = __sig or typed_dict_signature(__dct, **kwargs)
    
    defaults = {
        k: v.default for k, v in sig.parameters.items() 
        if v.default is not Parameter.empty
    }
    
    defaults.update({k:v for k,v in kwargs.items() if k in defaults})
    if not __non: defaults = {k:v for k,v in defaults.items() if not isnone(v)}
    return __dct(**defaults)

# %% ../nbs/01_core.ipynb 41
def typed_dict_func(
    __dct: T, 
    __sig: Signature | None = None,
    __non: bool = True, 
) -> Callable[[T, Signature], Callable[P, T]]:
    '''Returns a partial function for creating TypedDict instances with defaults 
    and potentially non-values excluded.

    Parameters
    ----------
    __dct : TypedDict
        The TypedDict class for which instances will be created.
        
    __sig : Signature, optional
        The signature to use for the TypedDict. If not provided, it will be generated.
        
    __non : bool, default: True
        Determines whether non-values (None) should be included in the output.

    Returns
    -------
    Callable
        A partial function that can be used to create instances of the TypedDict.
    '''
    return partial(typed_dict_defaults, __dct, __sig=__sig, __non=__non)

# %% ../nbs/01_core.ipynb 45
def get_typed_dict_keywords(
    __dct: T, 
    __pop_keyword: bool = True, 
    __defaults: T | None = None, 
    **kwargs: K
) -> T:
    '''Get the keywords arguments as specified in a `TypedDict`.
    
    Parameters
    ----------
    __pop_keyword : bool, default: True
        Whether to remove the keyword from the `kwargs` dictionary, by default True
        
    __defaults : T, optional
        The default values for the `TypedDict`, by default None
        
    kwargs : dict
        The keyword arguments to be added to the `TypedDict`
        
    Returns
    -------
    T
        The `TypedDict` with the keyword arguments added
    '''
    kwds = __defaults or {}
    anns = get_annotations(__dct)
    # unmangled annotation names
    unmg = unmangled_annotations(__dct)
    keys = list(kwargs.keys())
    for key in keys:
        mkw = mangled(__dct, key) # mangled keyword name
        if (
            key in unmg or # key is in the unmangled keywords
            key in anns or # key is a mangled keyword
            mkw in anns # if the mangled keyword is in the annotations
        ): 
            ukw = unmangle(__dct, key)    # unmangled the keyword name
            kwds[ukw] = kwargs.get(key) # add the unmangled keyword and its value to the result
            if __pop_keyword:  kwargs.pop(key, None)
            continue
    return kwds

# %% ../nbs/01_core.ipynb 47
def prune_type_dict_keywords(__dct: T, **kwargs) -> T:
    keys = set()
    anns = get_annotations(__dct)
    unmg = unmangled_annotations(__dct)
    for key in kwargs:
        mkw = mangled(__dct, key)
        if (key in unmg or key in anns or mkw in anns): 
            keys.add(key)
    return dict(((k, v) for k, v in kwargs.items() if k not in keys))

# %% ../nbs/01_core.ipynb 49
class typedict(dict):
    '''A base class for creating TypedDict instances with default values and custom behaviors.

    Subclasses can specify TypedDict types and default values for their fields.
    '''
    def __init_subclass__(cls: Type[Self], **defs: K) -> None:
        '''
        Initializes a subclass with specified TypedDict defaults 
        and optional custom signature.

        Parameters
        ----------
        **defs : TypedDict
            Defaults and TypedDict specifications for the subclass.

        Raises
        ------
        KeyError
            If __dct is not provided in the subclass definition.
        '''
        super().__init_subclass__()
        sub = defs.pop('__subclass', False)
        typ = getattr(cls, '__dct', None)
        try:
            cls.__dct = defs.pop('__dct', typ)
            if isnone(cls.__dct): raise KeyError('__dct')
            cls.__non = defs.pop('__non', True)
            cls.__sig = defs.pop('__sig', typed_dict_signature(cls.__dct, **defs))
            
        except (KeyError, AttributeError) as err:
            if not sub: 
                raise err
        return
    
    def __init__(self: Self, *args: P.args, **kwargs: P.kwargs):
        '''Initializes an instance of the subclass with default values 
        and optional overrides.

        Parameters
        ----------
        *args
            Unused, present to comply with the dict interface.
            
        **kwargs
            Field values that override the defaults specified in the subclass.
        '''
        kwargs.pop('__dct', None)
        kwargs.pop('__sig', None)
        __non = kwargs.pop('__non', True)
        kwds = typed_dict_defaults(type(self).__dct, __sig=type(self).__sig, __non=__non, **kwargs)
        super().__init__(*args, **kwds)
        
    def __instancecheck__(self, __instance) -> bool:
        '''Checks if the instance is of the TypedDict type specified in the subclass.

        Parameters
        ----------
        __instance
            The instance to check.

        Returns
        -------
        bool
            True if the instance is of the correct TypedDict type, False otherwise.
        '''
        return super().__instancecheck__(__instance) or isinstance(__instance, type(self).__dct)
    
    def dropnones(self: Self, inplace: bool = True) -> Self:
        '''Removes keys with `None` values from the TypedDict instance.

        Parameters
        ----------
        inplace : bool, default: True
            If True, modifies the instance in place; otherwise, 
            returns a new instance without `None` values.

        Returns
        -------
        Self
            The instance itself if inplace is True, otherwise a new instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def filter(cls: Type[Self], __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.

        Parameters
        ----------
        __defaults : T, optional
            The default values for the `TypedDict`, by default None
            
        kwargs : dict
            The keyword arguments to be added to the `TypedDict`
            
        Returns
        -------
        Self
            An instance of the `TypedDict` with the keyword arguments added
        '''
        return get_typed_dict_keywords(cls.__dct, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls: Type[Self], **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        return prune_type_dict_keywords(cls.__dct, **kwargs)
        return cls(prune_type_dict_keywords(cls.__dct, **kwargs))

# %% ../nbs/01_core.ipynb 51
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class dtyp(typedict, __subclass=True): 
    ...
    
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class typekwds(typedict, __subclass=True): 
    ...
    
@wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
class tdict(typedict, __subclass=True): 
    ...

# %% ../nbs/01_core.ipynb 56
def new(d: T, **kwargs: K):
    '''A decorator for creating new typedict subclasses from a 
    TypedDict definition with specified defaults.

    Parameters
    ----------
    d : TypedDict
        The TypedDict definition to base the subclass on.
    **kwargs : TypedDict
        Default values for the TypedDict fields.

    Returns
    -------
    Callable
        A decorator that when applied to a class, modifies it to be a typedict subclass.
    '''
    
    def decorator(func: Callable):
        '''A decorator for functions to automatically fill in TypedDict 
        based on its signature and provided defaults.

        Parameters
        ----------
        d : TypedDict
            The TypedDict definition to base the argument filling on.
        **kwargs : TypedDict
            Default values for the TypedDict fields.

        Returns
        -------
        Callable
            A decorator that when applied to a function, wraps it so that its keyword 
            arguments are filled in based on the TypedDict and defaults.
        '''
        __non = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        
        @wraps(typedict, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
        class wrapper(typedict, __dct=d, __sig=signature, __non=__non, __subclass=True):
            ...
        wrapper.__signature__ = signature
        wrapper.__annotations__ = d.__annotations__
        try: 
            wrapper.__doc__  = d.__doc__
            wrapper.__call__ = d.__doc__
            wrapper.__init__.__signature__ = signature
            wrapper.__init__.__annotations__ = d.__annotations__
            wrapper.__annotations__ = d.__annotations__
        except: pass
        return wrapper
    
    return decorator

# %% ../nbs/01_core.ipynb 59
def setkeywords(d: T, **kwargs: K):
    
    def decorator(func: Callable):
        dropnones = kwargs.pop('__non', True)
        signature = typed_dict_signature(d, **kwargs)
        construct = typed_dict_func(d, signature, dropnones)
        
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__))
        def wrapper(**kwargs: Type[d]) -> Type[d]:
            kwds = construct(**kwargs)
            return d(**kwds)
        wrapper.__signature__ = signature
        return wrapper
    
    return decorator
