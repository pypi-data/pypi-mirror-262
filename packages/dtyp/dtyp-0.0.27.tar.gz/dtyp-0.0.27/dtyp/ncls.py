# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/10_ncls.ipynb.

# %% auto 0
__all__ = ['TypedDictMeta', 'TypeDict', 'dtyp', 'typedict', 'tdict', 'tkws', 'TypeKwds', 'typekwds', 'new']

# %% ../nbs/10_ncls.ipynb 6
from functools import wraps, partial

# %% ../nbs/10_ncls.ipynb 8
from typing import (Self, Callable, TypedDict, get_type_hints)

# %% ../nbs/10_ncls.ipynb 10
#| export


# %% ../nbs/10_ncls.ipynb 12
#| export


# %% ../nbs/10_ncls.ipynb 14
from .cons import (__DOC__, __NEW__, __MODULE__, __DEFAULTS__, __TYPEDICT__, __ANNOTATIONS__, __NAME__, __QUALNAME__)
from .atyp import T, P, K
from .grds import isnone, notnone, isdunder, ismangled
from .util import getname, wrapper_signature_update
from .sigs import typed_dict_signature
from .tdct import (typed_dict_defaults, get_typed_dict_keywords, prune_type_dict_keywords)

# %% ../nbs/10_ncls.ipynb 17
class TypedDictMeta(type):
    __typedict__: dict
    '''The `TypedDict` created when subclassed''';
    
    __defaults__: dict = dict()
    '''Default values for the `TypeDict`''';
    
    def __instancecheck__(cls, instance):
        if not isinstance(instance, dict): return False
        given = get_type_hints(cls)
        found = {k: type(v) for k, v in instance.items()}
        # Simplified type checking logic
        return all(given.get(k) == found.get(k) for k in given)
    
    def __new__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        new = super().__new__(cls, name, bases, namespace)
        return new
    
    def __defs__(cls, **kwargs: P.kwargs) -> dict:
        anns = get_type_hints(cls)
        base = typed_dict_defaults(cls.__typedict__)
        
        defs = cls() if issubclass(cls, dict) else dict()
        base.update(defs)
        base.update({k: v for k, v in cls.__dict__.items() if k in anns})
        base.update({k: v for k, v in kwargs.items() if (k in base)})
        return base
    
    def __init__(cls, name: str, bases: tuple[type, ...] = (), namespace: dict = dict(), **kwargs: P.kwargs):
        super().__init__(cls, name, bases)
        setattr(cls, __TYPEDICT__, TypedDict( f'{name}_typeddict', get_type_hints(cls)))
        defs = cls.__defs__(**kwargs)
        setattr(cls, __DEFAULTS__, defs)

# %% ../nbs/10_ncls.ipynb 19
class TypeDict(dict, metaclass=TypedDictMeta):
    def __init_subclass__(cls, *args: P.args, **kwargs: P.kwargs):
        super().__init_subclass__()

    def __new__(cls, *args: P.args, **kwargs: P.kwargs):
        newdct = super().__new__(cls, *args, **kwargs)
        joined = {**cls.__defaults__, **kwargs}
        newdct.update(joined)
        return newdct
    
    def dropnones(self, inplace: bool = True):
        '''Removes keys with `None` values from the TypedDict instance.'''
        bad = {k for k, v in self.items() if isnone(v)}
        if inplace:
            for k in bad: self.pop(k)
            return self
        sub = {k: v for k, v in self.items() if k in bad}
        return type(self)(sub)
    
    @classmethod
    def filter(cls, __defaults: T | None = None, **kwargs: K) -> Self: 
        '''Filter the keywords in **kwargs to just those specified in the class's TypedDict.'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return get_typed_dict_keywords(tdict, __defaults=__defaults, **kwargs)
    
    @classmethod
    def remove(cls, **kwargs: K): 
        '''Remove the keywords in **kwargs from the class's TypedDict'''
        tdict = getattr(cls, __TYPEDICT__, dict())
        return prune_type_dict_keywords(tdict, **kwargs)

# %% ../nbs/10_ncls.ipynb 20
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class dtyp(TypeDict, __subclass=True):  ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typedict(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tdict(TypeDict, __subclass=True): ...
    

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class tkws(TypeDict, __subclass=True): ...
    
@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class TypeKwds(TypeDict, __subclass=True): ...

@wraps(TypeDict, assigned = (__MODULE__, __DOC__, __ANNOTATIONS__), updated=())
class typekwds(TypeDict, __subclass=True): ...

# %% ../nbs/10_ncls.ipynb 28
def _not_class_key(key: str, cls: Callable) -> bool:
    return not isdunder(key) and not ismangled(getname(cls), key)

def _cls_keys(cls: Callable, annots_only: bool = False):
    filt = partial(_not_class_key, cls=cls)
    ukey = list(filter(filt, cls.__dict__))
    tkey = list(get_type_hints(cls))
    keys = set(tkey + ([] if annots_only else ukey))
    return sorted(keys)

# %% ../nbs/10_ncls.ipynb 29
def new(d: T, **kwargs: K):
    def decorator(func: Callable):
        signature = typed_dict_signature(d, **kwargs)
        inval = dict((k, v) for k  in _cls_keys(func) if notnone(v := getattr(func, k, None)))
        bases = getattr(d, '__bases__', ()) + (TypeDict, )
        kwargs.update(inval)
        @wraps(func, assigned = (__MODULE__, __NAME__, __QUALNAME__, __DOC__), updated=())
        class subdict(d, func, *bases, **kwargs):
            ...
        subdict.__signature__ = signature
        subdict = wrapper_signature_update(subdict, signature, d)
        return subdict
    
    return decorator
