# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/41_plib.ipynb.

# %% auto 0
__all__ = ['givedoc', 'givedocs', 'givewrap', 'givewraps', 'PLib']

# %% ../nbs/41_plib.ipynb 5
from pathlib import Path

# %% ../nbs/41_plib.ipynb 7
from atyp import StrQ, ListQ
from nlit import (__DOC__, __FSPATH__, )
from typing import (Callable,)
from functools import wraps

# %% ../nbs/41_plib.ipynb 9
from .util import aspath

# %% ../nbs/41_plib.ipynb 11
def givedoc(cls, kls, attr):
    try: setattr(getattr(cls, attr), __DOC__, getattr(getattr(kls, attr), __DOC__))
    except (TypeError, AttributeError): pass

def givedocs(cls, kls):
    for attr in dir(cls): givedoc(cls, kls, attr)

def givewrap(cls, kls, attr):
    if not isinstance(getattr(kls, attr), (property, Callable)): return
    try: setattr(cls, attr, wraps(getattr(kls, attr))(getattr(cls, attr)))        
    except (TypeError, AttributeError): givedoc(cls, kls, attr)
    
def givewraps(cls, kls): 
    for attr in dir(kls): givewrap(cls, kls, attr)

# %% ../nbs/41_plib.ipynb 12
class PLib:
    # Is type
    def is_dir(self): return self.path.is_dir()
    def is_file(self): return self.path.is_file()
    def is_fifo(self): return self.path.is_fifo()
    def is_mount(self): return self.path.is_mount()
    def is_socket(self): return self.path.is_socket()
    def is_symlink(self): return self.path.is_symlink()
    def is_char_device(self): return self.path.is_char_device()
    def is_block_device(self): return self.path.is_block_device()
    
    # Properties
    @property
    def root(self): return self.path.root
    @property
    def name(self): return self.path.name
    @property
    def stem(self): return self.path.stem
    @property
    def drive(self): return self.path.drive
    @property
    def parts(self): return self.path.parts
    @property
    def anchor(self): return self.path.anchor
    @property
    def suffix(self): return self.path.suffix
    @property
    def parent(self): return self.path.parent
    @property
    def parents(self): return self.path.parents
    @property
    def suffixes(self): return self.path.suffixes
    @property
    def _flavour(self): return self.path._flavour
    
    # Methods
    def ls(self, n_max=None, file_type=None, file_exts=None): return self.path.ls(n_max, file_type, file_exts)
    @classmethod
    def cwd(cls): return cls.path.cwd()    
    def open(
        self, mode: str = 'r', buffering: int = -1, encoding: StrQ = None,
        errors: StrQ = None, newline: StrQ = None
    ):
        return self.path.open(mode, buffering, encoding, errors, newline)
    def glob(self, pattern): return self.path.glob(pattern)
    @classmethod
    def home(cls): return cls.path.home()
    def stat(self): return self.path.stat()

    def lstat(self): return self.path.lstat()
    def rmdir(self): return self.path.rmdir()
    def touch(self, mode: int = 438, exist_ok: bool = True): return self.path.touch(mode, exist_ok)
    def mkdir(self, mode: int = 511, parents: bool = False, exist_ok: bool = False):
        return self.path.mkdir(mode, parents, exist_ok)
    def chmod(self, mode): return self.path.chmod(mode)
    def owner(self): return self.path.owner()
    def group(self): return self.path.group()
    def rglob(self, pattern): return self.path.rglob(pattern)
    def match(self, pattern): return self.path.match(pattern)

    def delete(self): return self.path.delete()
    def lchmod(self, mode): return self.path.lchmod(mode)
    def rename(self, target): return self.path.rename(target)
    def unlink(self): return self.path.unlink()
    def exists(self): return self.path.exists()
    def as_uri(self): return self.path.as_uri()
    
    def resolve(self): return self.path.resolve()
    def link_to(self, target: Path): return self.path.link_to(target)
    def relpath(self, start: Path = None): return self.path.relpath(start)
    def replace(self, target): return self.path.replace(target)
    def iterdir(self): return self.path.iterdir()

    def as_posix(self): return self.path.as_posix()
    def samefile(self, other): return self.path.samefile(other)
    def joinpath(self, *other): return self.path.joinpath(*other)
    def mk_write(self, data, encoding: StrQ = None, errors: ListQ = None, mode: int = 511): 
        return self.path.mk_write(data, encoding, errors, mode)    
    def absolute(self): return self.path.absolute()
    def readlink(self): return self.path.readlink()
    def _scandir(self): return self.path._scandir()

    def with_name(self, name): return self.path.with_name(name)
    def with_stem(self, stem): return self.path.with_stem(stem)
    def read_text(self, *args, **kwargs): return self.path.read_text(*args, **kwargs)
    def read_json(self, encoding: StrQ = None, errors: ListQ = None): return self.path.read_json(encoding, errors)
    def readlines(self, hint: int = -1, encoding: str = 'utf8'): return self.path.readlines(hint, encoding)

    def expanduser(self): return self.path.expanduser()
    def read_bytes(self): return self.path.read_bytes()
    def symlink_to(self, target, target_is_directory): return self.path.symlink_to(target, target_is_directory)
    def write_text(self, data, encoding: StrQ = None, errors: StrQ = None, newline: StrQ = None):
        return self.path.write_text(data, encoding, errors, newline)

    def is_absolute(self): return self.path.is_absolute()
    def is_reserved(self): return self.path.is_reserved()
    def write_bytes(self, data): return self.path.write_bytes(data)
    def with_suffix(self, suffix): return self.path.with_suffix(suffix)
    def relative_to(self, *other): return self.path.relative_to(*other)
    
    def hardlink_to(self, target): return self.path.hardlink_to(target)
    def is_relative_to(self, *other): return self.path.is_relative_to(*other)
    def _from_parsed_parts(self, args): return self.path._from_parsed_parts(args)
    def _make_child_relpath(self, part): return self.path._make_child_relpath(part)
    def _format_parsed_parts(cls, attr): return cls.path._format_parsed_parts(attr)
    
    def __eq__(self, other): return self.path == aspath(other)
    def __lt__(self, other): return self.path <  aspath(other)
    def __le__(self, other): return self.path <= aspath(other)
    def __gt__(self, other): return self.path >  aspath(other)
    def __ge__(self, other): return self.path >= aspath(other)
    def __str__(self): return self.path.__str__()
    def __repr__(self): return self.path.__repr__()
    def __hash__(self): return self.path.__hash__()
    def __bytes__(self): return self.path.__bytes__()
    def __fspath__(self): return self.path.__fspath__()
    def __reduce__(self): return self.path.__reduce__()
    def __truediv__(self, other): return type(self)(str(self.path / aspath(other)))
    def __rtruediv__(self, other): return type(self)(str(aspath(other) / self.path))


    def __new__(cls, path: StrQ = None, *args, **kwargs):
        return super().__new__(cls, aspath(path))
    
    def __init__(self, path: StrQ = None, *args, **kwargs):
        self.path = path

    def __repr__(self): return f'{self.clsname}({self.path})'

# %% ../nbs/41_plib.ipynb 13
givewraps(PLib, Path)
