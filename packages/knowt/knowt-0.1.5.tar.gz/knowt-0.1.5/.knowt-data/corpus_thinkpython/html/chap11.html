<html>
<head>
<title>Chapter 11: Files and exceptions</title>

<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #ffc400;}
-->
</style>

</head>

<body bgcolor=white>

<table width=500><tr><td>
This is an older version of the book now known as <i>Think Python</i>.  You might prefer to <a href="../../../../greenteapress.com/wp/think-python-2e/index.html">read a more recent version</a>.


<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">

  <tr>
    <td width="20"><a href="chap10.html"><img border="0" alt="Previous" src="images/prev.png"></a></td>
    <td width="20"><a href="index.html"><img border="0" alt="Up" src="images/up.png"></a></td>
    <td width="20"><a href="chap12.html"><img border="0" alt="Next" src="images/next.png"></a></td>
    <td center>How to Think Like a Computer Scientist</td>
    <td width="20"><a href="dex.html"><img border="0" alt="Index" src="images/index.png"></a></td>
  </tr>

</table>
<hr>



<h2>Chapter 11</h2>



<h1>Files and exceptions</h1>
<p>
While a program is running, its data is in memory.  When the program
ends, or the computer shuts down, data in memory disappears.  To
store data permanently, you have to put it in a <b>file</b>.
Files are usually stored on a
hard drive, floppy drive, or CD-ROM.
<p>
When there are a large number of files, they are often organized
into <b>directories</b> (also called "folders").
Each file is identified by a unique name, or a combination of a
file name and a directory name.
<p>
By reading and writing files, programs can
exchange information with each other and generate printable formats
like PDF.
<p>
Working with files is a lot like working with books.  To use a book,
you have to open it.  When you're done, you have to close it.  While
the book is open, you can either write in it or read from it.  In
either case, you know where you are in the book.  Most of the time,
you read the whole book in its natural order, but you can also skip
around.
<p>
All of this applies to files as well.  To open a file, you specify
its name and indicate whether you want to read or write.
<p>
Opening a file creates a file object.  In this example,
the variable <tt><font size=-1>f</font></tt> refers to the new file object.

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.dat"</font>,<font color=red>"w"</font>)
<br>&gt;&gt;&gt; <font color=black>print</font> f
<br>&lt;open file <font color=red>'test.dat'</font>, mode <font color=red>'w'</font> at fe820&gt;
<br></font></tt></p>

<p>
The open function takes two arguments.  The first is the name of the file,
and the second is the mode.  Mode <tt><font size=-1><font color=red>"w"</font></font></tt> means that we are opening
the file for writing.
<p>
If there is no file named <tt><font size=-1>test.dat</font></tt>, it will be created.
If there already is one, it will be replaced by the file we are
writing.
<p>
When we print the file object, we see the name of the file, the
mode, and the location of the object.
<p>
To put data in the file we invoke the <tt><font size=-1>write</font></tt> method on the
file object:

<p><tt><font size=-1>&gt;&gt;&gt; f.write(<font color=red>"Now is the time"</font>)
<br>&gt;&gt;&gt; f.write(<font color=red>"to close the file"</font>)
<br></font></tt></p>

<p>
Closing the file tells the system that we are done writing and
makes the file available for reading:

<p><tt><font size=-1>&gt;&gt;&gt; f.close()
<br></font></tt></p>

<p>
Now we can open the file again, this time for reading, and read the
contents into a string.  This time, the mode argument
is <tt><font size=-1><font color=red>"r"</font></font></tt> for reading:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.dat"</font>,<font color=red>"r"</font>)
<br></font></tt></p>

<p>
If we try to open a file that doesn't exist, we get an error:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.cat"</font>,<font color=red>"r"</font>)
<br>IOError: [Errno 2] No such file <font color=black>or</font> directory: <font color=red>'test.cat'</font>
<br></font></tt></p>

<p>
Not surprisingly, the <tt><font size=-1>read</font></tt> method reads data from the
file.  With no arguments, it reads the entire contents of the file:

<p><tt><font size=-1>&gt;&gt;&gt; text = f.read()
<br>&gt;&gt;&gt; <font color=black>print</font> text
<br>Now <font color=black>is</font> the timeto close the file
<br></font></tt></p>

<p>
There is no space between "time" and "to" because we did
not write a space between the strings.
<p>
<tt><font size=-1>read</font></tt> can also take an argument that indicates how many
characters to read:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.dat"</font>,<font color=red>"r"</font>)
<br>&gt;&gt;&gt; <font color=black>print</font> f.read(5)
<br>Now i
<br></font></tt></p>

<p>
If not enough characters are left in the file,
<tt><font size=-1>read</font></tt> returns the remaining characters.
When we get to the end of the file,
<tt><font size=-1>read</font></tt> returns the empty string:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> f.read(1000006)
<br>s the timeto close the file
<br>&gt;&gt;&gt; <font color=black>print</font> f.read()
<br>
<br>&gt;&gt;&gt;
<br></font></tt></p>

<p>
The following function copies a file, reading and writing
up to fifty characters at a time.  The first argument is the name of
the original file; the second is the name of the new file:

<p><tt><font size=-1><font color=black>def</font> <font color=orange>copyFile</font>(oldFile, newFile):
<br>&nbsp; f1 = open(oldFile, <font color=red>"r"</font>)
<br>&nbsp; f2 = open(newFile, <font color=red>"w"</font>)
<br>&nbsp; <font color=black>while</font> True:
<br>&nbsp; &nbsp; text = f1.read(50)
<br>&nbsp; &nbsp; <font color=black>if</font> text == <font color=red>""</font>:
<br>&nbsp; &nbsp; &nbsp; <font color=black>break</font>
<br>&nbsp; &nbsp; f2.write(text)
<br>&nbsp; f1.close()
<br>&nbsp; f2.close()
<br>&nbsp; <font color=black>return</font>
<br></font></tt></p>

<p>
The <tt><font size=-1><font color=black>break</font></font></tt> statement is new.  Executing it breaks out of the
loop; the flow of execution moves to the first statement after
the loop.
<p>
In this example, the <tt><font size=-1><font color=black>while</font></font></tt> loop is infinite because the
value <tt><font size=-1>True</font></tt> is always true.  The <i>only</i> way to get out
of the loop is to execute <tt><font size=-1><font color=black>break</font></font></tt>, which happens when
<tt><font size=-1>text</font></tt> is the empty string, which happens when we get to
the end of the file.

<a name=1></a>
<h3>11.1 Text files</h3>
<p>
A <b>text file</b> is a file that contains printable characters and
whitespace, organized into lines separated by newline characters.
Since Python is specifically designed to process text files, it
provides methods that make the job easy.
<p>
To demonstrate, we'll
create a text file with three lines of text separated by
newlines:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.dat"</font>,<font color=red>"w"</font>)
<br>&gt;&gt;&gt; f.write(<font color=red>"line one\nline two\nline three\n"</font>)
<br>&gt;&gt;&gt; f.close()
<br></font></tt></p>

<p>
The <tt><font size=-1>readline</font></tt> method reads all the characters
up to and including the next newline character:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.dat"</font>,<font color=red>"r"</font>)
<br>&gt;&gt;&gt; <font color=black>print</font> f.readline()
<br>line one
<br>
<br>&gt;&gt;&gt;
<br></font></tt></p>

<p>
<tt><font size=-1>readlines</font></tt> returns all of the remaining
lines as a list of strings:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> f.readlines()
<br>[<font color=red>'line two\012'</font>, <font color=red>'line three\012'</font>]
<br></font></tt></p>

<p>
In this case, the output is in list format, which means that the
strings appear with quotation marks and the newline character
appears as the escape sequence <tt><font size=-1>&lt;br&gt;012</font></tt>.
<p>
At the end of the file, <tt><font size=-1>readline</font></tt> returns the empty string
and <tt><font size=-1>readlines</font></tt> returns the empty list:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> f.readline()
<br>
<br>&gt;&gt;&gt; <font color=black>print</font> f.readlines()
<br>[]
<br></font></tt></p>

<p>
The following is an example of a line-processing program.
<tt><font size=-1>filterFile</font></tt> makes a copy of <tt><font size=-1>oldFile</font></tt>, omitting
any lines that begin with <tt><font size=-1><font color=#009000>#</font></font></tt>:

<p><tt><font size=-1><font color=black>def</font> <font color=orange>filterFile</font>(oldFile, newFile):
<br>&nbsp; f1 = open(oldFile, <font color=red>"r"</font>)
<br>&nbsp; f2 = open(newFile, <font color=red>"w"</font>)
<br>&nbsp; <font color=black>while</font> True:
<br>&nbsp; &nbsp; text = f1.readline()
<br>&nbsp; &nbsp; <font color=black>if</font> text == <font color=red>""</font>:
<br>&nbsp; &nbsp; &nbsp; <font color=black>break
<br>&nbsp; &nbsp; if</font> text[0] == <font color=red>'#'</font>:
<br>&nbsp; &nbsp; &nbsp; <font color=black>continue</font>
<br>&nbsp; &nbsp; f2.write(text)
<br>&nbsp; f1.close()
<br>&nbsp; f2.close()
<br>&nbsp; <font color=black>return</font>
<br></font></tt></p>

<p>
The <tt><font size=-1><font color=black>continue</font></font></tt> statement ends the current iteration of the
loop, but continues looping.  The flow of
execution moves to the top of the loop, checks the condition,
and proceeds accordingly.
<p>
Thus, if <tt><font size=-1>text</font></tt> is the empty string, the loop exits.  If
the first character of <tt><font size=-1>text</font></tt> is a hash mark, the flow
of execution goes to
the top of the loop.  Only if both conditions fail do we copy
<tt><font size=-1>text</font></tt> into the new file.

<a name=2></a>
<h3>11.2 Writing variables</h3>
<p>
The argument of <tt><font size=-1>write</font></tt> has to be a string, so if we want
to put other values in a file, we have to convert them to
strings first.  The easiest way to do that is with the <tt><font size=-1>str</font></tt>
function:

<p><tt><font size=-1>&gt;&gt;&gt; x = 52
<br>&gt;&gt;&gt; f.write (str(x))
<br></font></tt></p>

<p>
An alternative is to use the <b>format operator</b> <tt><font size=-1>%</font></tt>.  When
applied to integers, <tt><font size=-1>%</font></tt> is the modulus operator.  But
when the first operand is a string, <tt><font size=-1>%</font></tt> is the format operator.
<p>
The first operand is the <b>format string</b>, and the second operand
is a tuple of expressions.  The result is a string that contains
the values of the expressions, formatted according to the format
string.
<p>
As a simple example, the <b>format sequence</b> <tt><font size=-1><font color=red>"%d"</font></font></tt> means that
the first expression in the tuple should be formatted as an
integer.  Here the letter <i>d</i> stands for "decimal":

<p><tt><font size=-1>&gt;&gt;&gt; cars = 52
<br>&gt;&gt;&gt; <font color=red>"%d"</font> % cars
<br><font color=red>'52'</font>
<br></font></tt></p>

<p>
The result is the string <tt><font size=-1><font color=red>'52'</font></font></tt>, which is not to be confused
with the integer value <tt><font size=-1>52</font></tt>.
<p>
A format sequence can appear anywhere in the format string,
so we can embed a value in a sentence:

<p><tt><font size=-1>&gt;&gt;&gt; cars = 52
<br>&gt;&gt;&gt; <font color=red>"In July we sold %d cars."</font> % cars
<br><font color=red>'In July we sold 52 cars.'</font>
<br></font></tt></p>

<p>
The format sequence <tt><font size=-1><font color=red>"%f"</font></font></tt> formats the next item in
the tuple as a floating-point number, and <tt><font size=-1><font color=red>"%s"</font></font></tt> formats
the next item as a string:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=red>"In %d days we made %f million %s."</font> % (34,6.1,<font color=red>'dollars'</font>)
<br><font color=red>'In 34 days we made 6.100000 million dollars.'</font>
<br></font></tt></p>

<p>
By default, the floating-point format prints six decimal places.
<p>
The number of expressions in the tuple has to match the number
of format sequences in the string.  Also, the types of the
expressions have to match the format sequences:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=red>"%d %d %d"</font> % (1,2)
<br>TypeError: <font color=black>not</font> enough arguments <font color=black>for</font> format string
<br>&gt;&gt;&gt; <font color=red>"%d"</font> % <font color=red>'dollars'</font>
<br>TypeError: illegal argument type <font color=black>for</font> built-<font color=black>in</font> operation
<br></font></tt></p>

<p>
In the first example, there aren't enough expressions; in the
second, the expression is the wrong type.
<p>
For more control over the format of numbers, we can specify
the number of digits as part of the format sequence:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=red>"%6d"</font> % 62
<br><font color=red>'&nbsp; &nbsp; 62'</font>
<br>&gt;&gt;&gt; <font color=red>"%12f"</font> % 6.1
<br><font color=red>'&nbsp; &nbsp; 6.100000'</font>
<br></font></tt></p>

<p>
The number after the percent sign is the minimum number of spaces
the number will take up.  If the value provided takes fewer digits,
leading spaces are added.  If the number of spaces is negative,
trailing spaces are added:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=red>"%-6d"</font> % 62
<br><font color=red>'62&nbsp; &nbsp; '</font>
<br></font></tt></p>

<p>
For floating-point numbers, we can also
specify the number of digits after the decimal point:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=red>"%12.2f"</font> % 6.1
<br><font color=red>'&nbsp; &nbsp; &nbsp; &nbsp; 6.10'</font>
<br></font></tt></p>

<p>
In this example, the result takes up twelve spaces and includes two
digits after the decimal.  This format is useful for printing
dollar amounts with the decimal points aligned.
<p>
For example, imagine a dictionary that contains
student names as keys and hourly wages as values.
Here is a function that prints the contents of the dictionary
as a formatted report:

<p><tt><font size=-1><font color=black>def</font> <font color=orange>report</font> (wages) :
<br>&nbsp; students = wages.keys()
<br>&nbsp; students.sort()
<br>&nbsp; <font color=black>for</font> student <font color=black>in</font> students :
<br>&nbsp; &nbsp; <font color=black>print</font> <font color=red>"%-20s %12.2f"</font> % (student, wages[student])
<br></font></tt></p>

<p>
To test this function, we'll create a small dictionary
and print the contents:

<p><tt><font size=-1>&gt;&gt;&gt; wages = {<font color=red>'mary'</font>: 6.23, <font color=red>'joe'</font>: 5.45, <font color=red>'joshua'</font>: 4.25}
<br>&gt;&gt;&gt; report (wages)
<br>joe&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 5.45
<br>joshua&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.25
<br>mary&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;6.23
<br></font></tt></p>

<p>
By controlling the width of each value, we guarantee that the columns
will line up, as long as the names contain fewer than twenty-one
characters and the wages are less than one billion dollars an hour.

<a name=3></a>
<h3>11.3 Directories</h3>
<p>
When you create a new file by opening it and writing, the new
file goes in the current directory (wherever you were when
you ran the program).  Similarly, when you open a file for
reading, Python looks for it in the current directory.
<p>
If you want to open a file somewhere else, you have to specify
the <b>path</b> to the file, which is the name of the directory
(or folder) where the file is located:

<p><tt><font size=-1>&gt;&gt;&gt;&nbsp; &nbsp;f = open(<font color=red>"/usr/share/dict/words"</font>,<font color=red>"r"</font>)
<br>&gt;&gt;&gt;&nbsp; &nbsp;<font color=black>print</font> f.readline()
<br>Aarhus
<br></font></tt></p>

<p>
This example opens a file named <tt><font size=-1>words</font></tt> that resides in a
directory named <tt><font size=-1>dict</font></tt>, which resides in <tt><font size=-1>share</font></tt>, which
resides in <tt><font size=-1>usr</font></tt>, which resides in the top-level directory
of the system, called <tt><font size=-1>/</font></tt>.
<p>
You cannot use <tt><font size=-1>/</font></tt>
as part of a filename; it is reserved as a delimiter between
directory and filenames.
<p>
The file <tt><font size=-1>/usr/share/dict/words</font></tt> contains a list of words
in alphabetical order, of which the first is the name of a
Danish university.

<a name=4></a>
<h3>11.4 Pickling</h3>
<p>
In order to put values into a file, you have to convert them
to strings.  You have already seen how to do that with <tt><font size=-1>str</font></tt>:

<p><tt><font size=-1>&gt;&gt;&gt; f.write (str(12.3))
<br>&gt;&gt;&gt; f.write (str([1,2,3]))
<br></font></tt></p>

<p>
The problem is that when you read the value back, you get a string.
The original type information has been lost.  In fact, you can't
even tell where one value ends and the next begins:

<p><tt><font size=-1>&gt;&gt;&gt;&nbsp; &nbsp;f.readline()
<br><font color=red>'12.3[1, 2, 3]'</font>
<br></font></tt></p>

<p>
The solution is <b>pickling</b>, so called because it "preserves"
data structures.  The <tt><font size=-1>pickle</font></tt> module contains the necessary
commands.  To use it, import <tt><font size=-1>pickle</font></tt> and then open the file in
the usual way:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>import</font> pickle
<br>&gt;&gt;&gt; f = open(<font color=red>"test.pck"</font>,<font color=red>"w"</font>)
<br></font></tt></p>

<p>
To store a data structure, use the <tt><font size=-1>dump</font></tt> method and
then close the file in the usual way:

<p><tt><font size=-1>&gt;&gt;&gt; pickle.dump(12.3, f)
<br>&gt;&gt;&gt; pickle.dump([1,2,3], f)
<br>&gt;&gt;&gt; f.close()
<br></font></tt></p>

<p>
Then we can open the file for reading and load the data structures
we dumped:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"test.pck"</font>,<font color=red>"r"</font>)
<br>&gt;&gt;&gt; x = pickle.load(f)
<br>&gt;&gt;&gt; x
<br>12.3
<br>&gt;&gt;&gt; type(x)
<br>&lt;type <font color=red>'float'</font>&gt;
<br>&gt;&gt;&gt; y = pickle.load(f)
<br>&gt;&gt;&gt; y
<br>[1, 2, 3]
<br>&gt;&gt;&gt; type(y)
<br>&lt;type <font color=red>'list'</font>&gt;
<br></font></tt></p>

<p>
Each time we invoke <tt><font size=-1>load</font></tt>, we get a single value from
the file, complete with its original type.

<a name=5></a>
<h3>11.5 Exceptions</h3>
<p>
Whenever a runtime error occurs, it creates an
<b>exception</b>.  Usually, the program stops and Python
prints 
an error message.
<p>
For example, dividing by zero creates an exception:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> 55/0
<br>ZeroDivisionError: integer division <font color=black>or</font> modulo
<br></font></tt></p>

<p>
So does accessing a nonexistent list item:

<p><tt><font size=-1>&gt;&gt;&gt; a = []
<br>&gt;&gt;&gt; <font color=black>print</font> a[5]
<br>IndexError: list index out of range
<br></font></tt></p>

<p>
Or accessing a key that isn't in the dictionary:

<p><tt><font size=-1>&gt;&gt;&gt; b = {}
<br>&gt;&gt;&gt; <font color=black>print</font> b[<font color=red>'what'</font>]
<br>KeyError: what
<br></font></tt></p>

<p>
Or trying to open a nonexistent file:

<p><tt><font size=-1>&gt;&gt;&gt; f = open(<font color=red>"Idontexist"</font>, <font color=red>"r"</font>)
<br>IOError: [Errno 2] No such file <font color=black>or</font> directory: <font color=red>'Idontexist'</font>
<br></font></tt></p>

<p>
In each case, the error
message has two parts: the type of error before
the colon, and specifics about the error after the colon.
Normally Python also prints a traceback of where the program
was, but we have omitted that from the examples.
<p>
Sometimes we want to execute an operation that could cause
an exception, but we don't want the program to stop.  We can
<b>handle</b> the exception using the <tt><font size=-1><font color=black>try</font></font></tt> and
<tt><font size=-1><font color=black>except</font></font></tt> statements.
<p>
For example, we might prompt the user for the name of a file
and then try to open it.  If the file doesn't exist, we don't
want the program to crash; we want to handle the exception:

<p><tt><font size=-1>filename = raw_input(<font color=red>'Enter a file name: '</font>)
<br><font color=black>try</font>:
<br>&nbsp; f = open (filename, <font color=red>"r"</font>)
<br><font color=black>except</font> IOError:
<br>&nbsp; <font color=black>print</font> <font color=red>'There is no file named'</font>, filename
<br></font></tt></p>

<p>
The <tt><font size=-1><font color=black>try</font></font></tt> statement executes the statements in the first block.
If no exceptions occur, it ignores the <tt><font size=-1><font color=black>except</font></font></tt> statement.  If an
exception of type <tt><font size=-1>IOError</font></tt> occurs, it executes the statements in
the <tt><font size=-1><font color=black>except</font></font></tt> branch and then continues.
<p>
We can encapsulate this capability in a function: <tt><font size=-1>exists</font></tt> takes a
filename and returns true if the file exists, false if it doesn't:

<p><tt><font size=-1><font color=black>def</font> <font color=orange>exists</font>(filename):
<br>&nbsp; <font color=black>try</font>:
<br>&nbsp; &nbsp; f = open(filename)
<br>&nbsp; &nbsp; f.close()
<br>&nbsp; &nbsp; <font color=black>return</font> True
<br>&nbsp; <font color=black>except</font> IOError:
<br>&nbsp; &nbsp; <font color=black>return</font> False
<br></font></tt></p>

<p>
You can use multiple <tt><font size=-1><font color=black>except</font></font></tt> blocks to handle different kinds of
exceptions.  The <i>Python Reference Manual</i> has the details.
<p>
If your program detects an error condition, you can make it
<b>raise</b> an exception.  Here is an example that gets input
from the user and checks for the value 17.  
Assuming that 17 is not valid input for some reason, we raise an
exception.

<p><tt><font size=-1><font color=black>def</font> <font color=orange>inputNumber</font> () :
<br>&nbsp; x = input (<font color=red>'Pick a number: '</font>)
<br>&nbsp; <font color=black>if</font> x == 17 :
<br>&nbsp; &nbsp; <font color=black>raise</font> ValueError, <font color=red>'17 is a bad number'</font>
<br>&nbsp; <font color=black>return</font> x
<br></font></tt></p>

<p>
The <tt><font size=-1><font color=black>raise</font></font></tt> statement takes two arguments: the exception type and
specific information about the error.  <tt><font size=-1>ValueError</font></tt> is one of the
exception types Python provides for a variety of occasions.  Other
examples include <tt><font size=-1>TypeError</font></tt>, <tt><font size=-1>KeyError</font></tt>, and my favorite,
<tt><font size=-1>NotImplementedError</font></tt>.
<p>
If the function that called <tt><font size=-1>inputNumber</font></tt> handles the error,
then the program can continue; otherwise, Python prints the
error message and exits:

<p><tt><font size=-1>&gt;&gt;&gt; inputNumber ()
<br>Pick a number: 17
<br>ValueError: 17 <font color=black>is</font> a bad number
<br></font></tt></p>

<p>
The error message includes the exception type and the
additional information you provided.

<blockquote><i>As an exercise, write a function that uses <tt><font size=-1>inputNumber</font></tt>
to input a number from the keyboard and that handles the
<tt><font size=-1>ValueError</font></tt> exception.</i>
</blockquote>

<a name=6></a>
<h3>11.6 Glossary</h3>

<dl>
<dt>file</dt>
<dd>A named entity, usually stored on a hard drive, floppy disk,
or CD-ROM, that contains a stream of characters.</dd>
<dt>directory</dt>
<dd>A named collection of files, also called a folder.</dd>
<dt>path</dt>
<dd>A sequence of directory names that specifies the
exact location of a file.</dd>
<dt>text file</dt>
<dd>A file that contains printable characters organized
into lines separated by newline characters.</dd>
<dt>break statement</dt>
<dd>A statement that causes the flow of execution
to exit a loop.</dd>
<dt>continue statement</dt>
<dd>A statement that causes the current iteration
of a loop to end.  The flow of execution goes to the top of the loop,
evaluates the condition, and proceeds accordingly.</dd>
<dt>format operator</dt>
<dd>The <tt><font size=-1>%</font></tt> operator takes a format
string and a tuple of expressions and yields a string that includes
the expressions, formatted according to the format string.</dd>
<dt>format string</dt>
<dd>A string that contains printable characters
and format sequences that indicate how to format values.</dd>
<dt>format sequence</dt>
<dd>A sequence of characters beginning with
<tt><font size=-1>%</font></tt> that indicates how to format a value.</dd>
<dt>pickle</dt>
<dd>To write a data value in a file along with its
type information so that it can be reconstituted later.</dd>
<dt>exception</dt>
<dd>An error that occurs at runtime.</dd>
<dt>handle</dt>
<dd>To prevent an exception from terminating
a program using the <tt><font size=-1><font color=black>try</font></font></tt>
and <tt><font size=-1><font color=black>except</font></font></tt> statements.</dd>
<dt>raise</dt>
<dd>To signal an exception using the <tt><font size=-1><font color=black>raise</font></font></tt>
statement.</dd>
</dl>
<p>

<p>
This is an older version of the book now known as <i>Think Python</i>.  You might prefer to <a href="../../../../greenteapress.com/wp/think-python-2e/index.html">read a more recent version</a>.


<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">

  <tr>
    <td width="20"><a href="chap10.html"><img border="0" alt="Previous" src="images/prev.png"></a></td>
    <td width="20"><a href="index.html"><img border="0" alt="Up" src="images/up.png"></a></td>
    <td width="20"><a href="chap12.html"><img border="0" alt="Next" src="images/next.png"></a></td>
    <td center>How to Think Like a Computer Scientist</td>
    <td width="20"><a href="dex.html"><img border="0" alt="Index" src="images/index.png"></a></td>
  </tr>

</table>
<hr>


</td></tr>
</table>
</body>
</html>

