<html>
<head>
<title>Appendix B: Creating a new data type</title>

<style type="text/css">
<!--
.code {font-family: Courier; font-size: 85%;}
.keyword {color: #0000ff;}
.comment {color: #008000;}
.quote {color: #ff0000;}
.function {color: #ffc400;}
-->
</style>

</head>

<body bgcolor=white>

<table width=500><tr><td>
This is an older version of the book now known as <i>Think Python</i>.  You might prefer to <a href="../../../../greenteapress.com/wp/think-python-2e/index.html">read a more recent version</a>.


<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">

  <tr>
    <td width="20"><a href="app01.html"><img border="0" alt="Previous" src="images/prev.png"></a></td>
    <td width="20"><a href="index.html"><img border="0" alt="Up" src="images/up.png"></a></td>
    <td width="20"><a href="app04.html"><img border="0" alt="Next" src="images/next.png"></a></td>
    <td center>How to Think Like a Computer Scientist</td>
    <td width="20"><a href="dex.html"><img border="0" alt="Index" src="images/index.png"></a></td>
  </tr>

</table>
<hr>



<h2>Appendix B</h2>



<h1>Creating a new data type</h1>
<p>
Object-oriented programming languages allow programmers to create new
data types that behave much like built-in data types.  We will explore
this capability by building a <tt><font size=-1>Fraction</font></tt> class that works very much
like the built-in numeric types: integers, longs and floats.
<p>
Fractions, also known as rational numbers, are values that can be expressed
as a ratio of whole numbers, such as <tt>5/6</tt>. The top number is
called the numerator and the bottom number is called the denominator.
<p>
We start by defining a <tt><font size=-1>Fraction</font></tt> class with an initialization
method that provides the numerator and denominator as integers:

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; <font color=black>def</font> <font color=orange>__init__</font>(self, numerator, denominator=1):
<br>&nbsp; &nbsp; self.numerator = numerator
<br>&nbsp; &nbsp; self.denominator = denominator
<br></font></tt></p>

<p>
The denominator is optional.  A Fraction with just one
parameter represents a whole number.  If the numerator
is <tt>n</tt>, we build the Fraction
<tt>n/1</tt>.
<p>
The next step is to write a <tt><font size=-1>__str__</font></tt> method that
displays fractions in a way that makes sense.  The form
"numerator/denominator" is natural here:

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; ...
<br>&nbsp; <font color=black>def</font> <font color=orange>__str__</font>(self):
<br>&nbsp; &nbsp; <font color=black>return</font> <font color=red>"%d/%d"</font> % (self.numerator, self.denominator)
<br></font></tt></p>

<p>
To test what we have so far, we put it in a file named
<tt><font size=-1>Fraction.py</font></tt> and import it into the Python interpreter.
Then we create a fraction object and print it.

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>from</font> Fraction <font color=black>import</font> Fraction
<br>&gt;&gt;&gt; spam = Fraction(5,6)
<br>&gt;&gt;&gt; <font color=black>print</font> <font color=red>"The fraction is"</font>, spam
<br>The fraction <font color=black>is</font> 5/6
<br></font></tt></p>

<p>
As usual, the <tt><font size=-1><font color=black>print</font></font></tt> command invokes the <tt><font size=-1>__str__</font></tt>
method implicitly.


<h3>Fraction multiplication</h3>
<p>
We would like to be able to apply the normal addition, subtraction,
multiplication, and division operations to fractions.  To do this, we
can overload the mathematical operators for <tt><font size=-1>Fraction</font></tt> objects.
<p>
We'll start with multiplication because it is the easiest to implement.
To multiply fractions, we create a new fraction with a numerator
that is the product of the original numerators and a denominator that
is a product of the original denominators.  <tt><font size=-1>__mul__</font></tt> is the
name Python uses for a method that overloads the <tt><font size=-1>*</font></tt> operator:

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; ...
<br>&nbsp; <font color=black>def</font> <font color=orange>__mul__</font>(self, other):
<br>&nbsp; &nbsp; <font color=black>return</font> Fraction(self.numerator*other.numerator,
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.denominator*other.denominator)
<br></font></tt></p>

<p>
We can test this method by computing the product of two fractions:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> Fraction(5,6) * Fraction(3,4)
<br>15/24
<br></font></tt></p>

<p>
It works, but we can do better!  We can extend the method to
handle multiplication by an integer.  We use the <tt><font size=-1>isinstance</font></tt> function
to test if <tt><font size=-1>other</font></tt> is an integer and convert it to a fraction if
it is.

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; ...
<br>&nbsp; <font color=black>def</font> <font color=orange>__mul__</font>(self, other):
<br>&nbsp; &nbsp; <font color=black>if</font> isinstance(other, int):
<br>&nbsp; &nbsp; &nbsp; other = Fraction(other)
<br>&nbsp; &nbsp; <font color=black>return</font> Fraction(self.numerator&nbsp; &nbsp;* other.numerator,
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.denominator * other.denominator)
<br></font></tt></p>

<p>
Multiplying fractions and integers now works, but only if the fraction
is the left operand:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> Fraction(5,6) * 4
<br>20/6
<br>&gt;&gt;&gt; <font color=black>print</font> 4 * Fraction(5,6)
<br>TypeError: __mul__ nor __rmul__ defined <font color=black>for</font> these operands
<br></font></tt></p>

<p>
To evaluate a binary operator like multiplication, Python checks
the left operand first to see if it provides a <tt><font size=-1>__mul__</font></tt>
that supports the type of the second operand.  In this case,
the built-in integer operator doesn't support fractions.
<p>
Next, Python checks the right operand to see if it provides
an <tt><font size=-1>__rmul__</font></tt> method that supports the first type.  In
this case, we haven't provided <tt><font size=-1>__rmul__</font></tt>, so it fails.
<p>
On the other hand, there is a simple way to provide
<tt><font size=-1>__rmul__</font></tt>:

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; ...
<br>&nbsp; __rmul__ = __mul__
<br></font></tt></p>

<p>
This assignment says that the <tt><font size=-1>__rmul__</font></tt> is the same
as <tt><font size=-1>__mul__</font></tt>.
Now if we evaluate <tt><font size=-1>4 * Fraction(5,6)</font></tt>, Python invokes
<tt><font size=-1>__rmul__</font></tt> on the <tt><font size=-1>Fraction</font></tt> object and passes 4
as a parameter:

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> 4 * Fraction(5,6)
<br>20/6
<br></font></tt></p>

<p>
Since <tt><font size=-1>__rmul__</font></tt> is the same as <tt><font size=-1>__mul__</font></tt>, and
<tt><font size=-1>__mul__</font></tt> can handle an integer parameter, we're all set.


<h3>Fraction addition</h3>
<p>
Addition is more complicated than multiplication, but still not too
bad.  The sum of <tt>a/b</tt> and <tt>c/d</tt> is the fraction
<tt><font size=-1>(a*d+c*b)/(b*d)</font></tt>.
<p>
Using the multiplication code as a model, we can write
<tt><font size=-1>__add__</font></tt> and <tt><font size=-1>__radd__</font></tt>:

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; ...
<br>&nbsp; <font color=black>def</font> <font color=orange>__add__</font>(self, other):
<br>&nbsp; &nbsp; <font color=black>if</font> isinstance(other, int):
<br>&nbsp; &nbsp; &nbsp; other = Fraction(other)
<br>&nbsp; &nbsp; <font color=black>return</font> Fraction(self.numerator&nbsp; &nbsp;* other.denominator +
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.denominator * other.numerator,
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self.denominator * other.denominator)
<br>
<br>&nbsp; __radd__ = __add__
<br></font></tt></p>

<p>
We can test these methods with <tt><font size=-1>Fraction</font></tt>s and integers.

<p><tt><font size=-1>&gt;&gt;&gt; <font color=black>print</font> Fraction(5,6) + Fraction(5,6)
<br>60/36
<br>&gt;&gt;&gt; <font color=black>print</font> Fraction(5,6) + 3
<br>23/6
<br>&gt;&gt;&gt; <font color=black>print</font> 2 + Fraction(5,6)
<br>17/6
<br></font></tt></p>

<p>
The first two examples invoke <tt><font size=-1>__add__</font></tt>; the last
invokes <tt><font size=-1>__radd__</font></tt>.


<h3>Euclid's algorithm</h3>
<p>
In the previous example, we computed the sum <tt>5/6 + 5/6</tt> and got
<tt>60/36</tt>.  That is correct, but it's not the best way to represent the
answer.  To <b>reduce</b> the fraction to its simplest terms, we have
to divide the numerator and denominator by their <b>greatest common
divisor (GCD)</b>, which is 12.  The result is <tt>5/3</tt>.
<p>
In general, whenever we create a new <tt><font size=-1>Fraction</font></tt> object, we should
reduce it by dividing the numerator and denominator by their GCD.  If
the fraction is already reduced, the GCD is 1.
<p>
Euclid of Alexandria (approx. 325--265 BCE) presented an algorithm
to find the GCD for two integers <tt>m</tt> and <tt>n</tt>:

<blockquote>If <tt>n</tt> divides <tt>m</tt> evenly, then <tt>n</tt> is the GCD.  Otherwise
the GCD is the GCD of <tt>n</tt> and the remainder of <tt>m</tt> divided by <tt>n</tt>.
</blockquote>
<p>
This recursive definition can be expressed concisely as a function:

<p><tt><font size=-1><font color=black>def</font> <font color=orange>gcd</font> (m, n):
<br>&nbsp; <font color=black>if</font> m % n == 0:
<br>&nbsp; &nbsp; <font color=black>return</font> n
<br>&nbsp; <font color=black>else</font>:
<br>&nbsp; &nbsp; <font color=black>return</font> gcd(n, m%n)
<br></font></tt></p>

<p>
In the first line of the body, we use the modulus operator to
check divisibility.  On the last line, we use it to compute
the remainder after division.
<p>
Since all the operations we've written
create new <tt><font size=-1>Fraction</font></tt>s for the result, we can reduce all results
by modifying the initialization method.

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; <font color=black>def</font> <font color=orange>__init__</font>(self, numerator, denominator=1):
<br>&nbsp; &nbsp; g = gcd (numerator, denominator)
<br>&nbsp; &nbsp; self.numerator&nbsp; &nbsp;=&nbsp; &nbsp;numerator / g
<br>&nbsp; &nbsp; self.denominator = denominator / g
<br></font></tt></p>

<p>
Now whenever we create a <tt><font size=-1>Fraction</font></tt>, it is reduced to its simplest
form:

<p><tt><font size=-1>&gt;&gt;&gt; Fraction(100,-36)
<br>-25/9
<br></font></tt></p>

<p>
A nice feature of <tt><font size=-1>gcd</font></tt> is that if the fraction is
negative, the minus sign is always moved to the numerator.


<h3>Comparing fractions</h3>
<p>
Suppose we have two <tt><font size=-1>Fraction</font></tt> objects, <tt><font size=-1>a</font></tt> and <tt><font size=-1>b</font></tt>, and we
evaluate <tt><font size=-1>a == b</font></tt>.  The default implementation of <tt><font size=-1>==</font></tt>
tests for shallow equality, so it only returns true if <tt><font size=-1>a</font></tt>
and <tt><font size=-1>b</font></tt> are the same object.
<p>
More likely, we want to return true if <tt>a</tt> and <tt>b</tt> have
the same value <s>&nbsp; &nbsp;</s> that is, deep equality.
<p>
We have to teach fractions how to compare themselves.  As we saw in
<a href="chap15.html#4">Section 15.4</a>, we can overload all the comparison
operators at once by supplying a <tt><font size=-1>__cmp__</font></tt> method.
<p>
By convention, the <tt><font size=-1>__cmp__</font></tt> method returns a
negative number if <tt><font size=-1>self</font></tt> is less than <tt><font size=-1>other</font></tt>, zero
if they are the same, and a positive number if <tt><font size=-1>self</font></tt> is greater
than <tt><font size=-1>other</font></tt>.
<p>
The simplest way to compare fractions is to cross-multiply.
If <tt>a/b > c/d</tt>, then <tt>ad > bc</tt>.
With that in mind, here is the code for <tt><font size=-1>__cmp__</font></tt>:

<p><tt><font size=-1><font color=black>class</font> Fraction:
<br>&nbsp; ...
<br>&nbsp; <font color=black>def</font> <font color=orange>__cmp__</font>(self, other):
<br>&nbsp; &nbsp; diff = (self.numerator&nbsp; * other.denominator -
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; other.numerator * self.denominator)
<br>&nbsp; &nbsp; <font color=black>return</font> diff
<br></font></tt></p>

<p>
If <tt><font size=-1>self</font></tt> is greater than <tt><font size=-1>other</font></tt>, then <tt><font size=-1>diff</font></tt>
will be positive.  If <tt><font size=-1>other</font></tt> is greater, then <tt><font size=-1>diff</font></tt>
will be negative.  If they are the same, <tt><font size=-1>diff</font></tt> is zero.


<h3>Taking it further</h3>
<p>
Of course, we are not done.  We still have to implement
subtraction by overriding <tt><font size=-1>__sub__</font></tt> and division
by overriding <tt><font size=-1>__div__</font></tt>.
<p>
One way to handle those operations is to implement negation
by overriding
<tt><font size=-1>__neg__</font></tt> and inversion by overriding <tt><font size=-1>__invert__</font></tt>.
Then we can subtract by negating the second operand and adding,
and we can divide by inverting the second operand and
multiplying.
<p>
Next, we have to provide <tt><font size=-1>__rsub__</font></tt> and <tt><font size=-1>__rdiv__</font></tt>.
Unfortunately, we can't use the same trick we used for addition and
multiplication, because subtraction and division are not commutative.
We can't just set <tt><font size=-1>__rsub__</font></tt> and <tt><font size=-1>__rdiv__</font></tt> equal to
<tt><font size=-1>__sub__</font></tt> and <tt><font size=-1>__div__</font></tt>.  In these operations, the
order of the operands makes a difference.
<p>
To handle <b>unary negation</b>, which is the use of the minus
sign with a single operand, we override <tt><font size=-1>__neg__</font></tt>.
<p>
We can compute powers by overriding <tt><font size=-1>__pow__</font></tt>,
but the implementation is a little tricky.  If the exponent isn't
an integer, then it may not be possible to represent the result
as a <tt><font size=-1>Fraction</font></tt>.  For example, <tt><font size=-1>Fraction(2) ** Fraction(1,2)</font></tt>
is the square root of 2, which is an irrational number (it can't
be represented as a fraction).
So it's not easy to write the most general version of <tt><font size=-1>__pow__</font></tt>.
<p>
There is one other extension to the <tt><font size=-1>Fraction</font></tt> class that you might
want to think about.  So far, we have assumed that the numerator
and denominator are integers.

<blockquote><i>As an exercise, finish the implementation of the <tt><font size=-1>Fraction</font></tt>
class so that it handles subtraction, division and exponentiation.</i>
</blockquote>


<h3>Glossary</h3>

<dl>
<dt>greatest common divisor (GCD)</dt>
<dd>The largest positive integer
that divides without a remainder into both the numerator and denominator
of a fraction.</dd>
<dt>reduce</dt>
<dd>To change a fraction into an equivalent form with a
GCD of 1.</dd>
<dt>unary negation</dt>
<dd>The operation that computes an additive
inverse, usually denoted with a leading minus sign.  Called 
"unary" by contrast with the binary minus operation, which is
subtraction.</dd>
</dl>

<p>
This is an older version of the book now known as <i>Think Python</i>.  You might prefer to <a href="../../../../greenteapress.com/wp/think-python-2e/index.html">read a more recent version</a>.


<hr>
<table width="100%" cellpadding="0" cellspacing="2" border="0">

  <tr>
    <td width="20"><a href="app01.html"><img border="0" alt="Previous" src="images/prev.png"></a></td>
    <td width="20"><a href="index.html"><img border="0" alt="Up" src="images/up.png"></a></td>
    <td width="20"><a href="app04.html"><img border="0" alt="Next" src="images/next.png"></a></td>
    <td center>How to Think Like a Computer Scientist</td>
    <td width="20"><a href="dex.html"><img border="0" alt="Index" src="images/index.png"></a></td>
  </tr>

</table>
<hr>


</td></tr>
</table>
</body>
</html>

