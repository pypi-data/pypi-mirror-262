<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.4" />
<title>lca_algebraic API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>lca_algebraic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# This file defines several utility functions above brightway2 to be used by notebooks
#
import re
import sys
from collections import defaultdict
from typing import Dict, Union, List, Any
import types
import brightway2 as bw
import numpy as np
import pandas as pd
from IPython.display import display
from bw2data.backends.peewee import Activity, ActivityDataset
from bw2data.parameters import ActivityParameter, ProjectParameter, DatabaseParameter, Group, ExchangeDataset
from sympy import Symbol, Basic, simplify, symbols
from sympy.parsing.sympy_parser import parse_expr
from slugify import slugify
from sympy.utilities.lambdify import lambdify
from collections import OrderedDict
from bw2data.backends.peewee.utils import dict_as_exchangedataset
from copy import deepcopy
from itertools import chain
import builtins
import matplotlib.pyplot as plt
from ipywidgets import interact, interactive, fixed, interact_manual
import ipywidgets as widgets
import warnings
from SALib.sample import saltelli
import math
from SALib.analyze import sobol
from scipy.stats import binned_statistic
import seaborn as sns
from sys import stderr
import math
from enum import Enum
from scipy.stats import triang
from scipy.stats import truncnorm
from math import sqrt

# -- Constants
DEBUG=False

def debug(*args, **kwargs) :
    if DEBUG :
        print(*args, **kwargs)

def error(*args, **kwargs):
    print(*args, **kwargs, file=stderr)

# DB names

ECOINVENT_DB_NAME = &#39;ecoinvent 3.4 cut off&#39;
BIOSPHERE3_DB_NAME = &#39;biosphere3&#39;

USER_DB_NAME = None

DEFAULT_PARAM_GROUP = &#34;acv&#34;

# Global
def _param_registry() :

    # Prevent reset upon auto reload in jupyter notebook
    if not &#39;param_registry&#39; in builtins.__dict__:
        builtins.param_registry = dict()

    return builtins.param_registry


# Sympy symbols
old_amount = symbols(&#34;old_amount&#34;)  # Can be used in epxression of amount for updateExchanges, in order to reference the previous value

NumOrExpression = Union[float, Basic]



class ParamType:
    &#39;&#39;&#39;Type of parameters&#39;&#39;&#39;
    ENUM = &#34;enum&#34;
    BOOL = &#34;bool&#34;
    FLOAT = &#34;float&#34;

class DistributionType :
    &#39;&#39;&#39;Type of distribution&#39;&#39;&#39;
    LINEAR = &#34;linear&#34;
    NORMAL = &#34;normal&#34;
    TRIANGLE = &#34;triangle&#34;
    FIXED = &#34;fixed&#34;

class ParamDef(Symbol):
    &#39;&#39;&#39;Generic definition of a parameter, with name, bound, type, distribution
    This definition will serve both to generate brightway2 parameters and to evaluate.

    This class inherits sympy Symbol, making it possible to use in standard arithmetic python
    while keeping it as a symbolic expression (delayed evaluation).
    &#39;&#39;&#39;

    def __new__(cls, name, *karg, **kargs):
        return Symbol.__new__(cls, name)

    def __init__(self, name, type: str, default, min=None, max=None, unit=&#34;&#34;, description=&#34;&#34;, label=None, label_fr=None, group=None, distrib=DistributionType.LINEAR, std=None):
        self.name = name
        self.type = type
        self.default = default
        self.description = description
        self.min = min
        self.max = max
        self.unit = unit
        self.label = label
        self.label_fr = label_fr
        self.group=group
        self.distrib = distrib

        if type == ParamType.FLOAT and self.min is None :
            self.distrib = DistributionType.FIXED

        if distrib == DistributionType.NORMAL and std is None :
            raise Exception(&#34;Standard deviation is mandatory for normal distribution&#34;)
        self.std = std

    def label(self):
        if self.label is not None :
            return self.label
        else :
            return self.name.replace(&#34;_&#34;, &#34; &#34;)

    def range(self, n) :
        &#39;&#39;&#39;Used for parametric analysis&#39;&#39;&#39;
        step = (self.max - self.min) / (n - 1)
        return list(i * step + self.min for i in range(0, n))


    def rand(self, alpha):
        &#34;&#34;&#34;Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter&#34;&#34;&#34;
        if self.distrib == DistributionType.LINEAR :
            return self.min + alpha * (self.max - self.min)

        elif self.distrib == DistributionType.TRIANGLE :
            if not hasattr(self, &#34;_distrib&#34;) :
                scale = self.max - self.min
                c = (self.default - self.min) / scale
                self._distrib = triang(c, loc=self.min, scale=scale)

            return self._distrib.ppf(alpha)

        elif self.distrib == DistributionType.NORMAL :
            if not hasattr(self, &#34;_distrib&#34;) :
                self._distrib = truncnorm(
                    (self.min - self.default) / self.std,
                    (self.max - self.min) / self.std,
                    loc=self.default,
                    scale=self.std)

            return self._distrib.ppf(alpha)

        else :
            raise Exception(&#34;Unknowk distribution type &#34; + self.distrib)



    # Expand parameter (useful for enum param)
    def expandParams(self, value=None) -&gt; Dict[str, float]:
        if value == None:
            value = self.default
        return {self.name: value}

    # Useful for enum param, having several names
    def names(self) :
        return [self.name]

    def __repr__(self):
        return self.name


class BooleanDef(ParamDef):
    &#34;&#34;&#34;Parameter with discrete value 0 or 1&#34;&#34;&#34;

    def __init__(self, name, **argv):
        super(BooleanDef, self).__init__(name, ParamType.BOOL, min=0, max=1, **argv)

    def range(self, n):
        return [0, 1]

    def rand(self, alpha):
        return round(alpha)




class EnumParam(ParamDef):
    &#34;&#34;&#34;Enum param is a facility representing a choice / switch as many boolean parameters.
    It is not itself a Sympy symbol. use #symbol(&#34;value&#34;) to access it&#34;&#34;&#34;

    def __init__(self, name, values: List[str], **argv):
        super(EnumParam, self).__init__(name, ParamType.ENUM, min=None, max=None, **argv)
        self.values = values

    def expandParams(self, currValue=None):
        values = self.values + [None]
        res = dict()
        for enum_val in values:
            var_name = &#34;%s_%s&#34; % (self.name, enum_val if enum_val is not None else &#34;default&#34;)
            res[var_name] = 1.0 if enum_val == currValue else 0.0
        return res

    def symbol(self, enumValue):
        &#34;&#34;&#34;Access parameter for each enum value : &lt;paramName&gt;_&lt;paramValue&gt;&#34;&#34;&#34;
        if enumValue is None:
            return Symbol(self.name + &#39;_default&#39;)
        if not enumValue in self.values:
            raise Exception(&#34;enumValue should be one of %s. Was %s&#34; % (str(self.values), enumValue))
        return Symbol(self.name + &#39;_&#39; + enumValue)

    def names(self) :
        return [&#34;%s_%s&#34; % (self.name, value) for value in (self.values + [&#34;default&#34;]) ]

    def rand(self, alpha):
        i = math.ceil(alpha * (len(self.values))) -1
        return self.values[int(i)]

    def range(self, n):
        return self.values


class ActivityExtended(Activity):
    &#34;&#34;&#34;Improved API for activity : adding a few useful methods.
    Those methods are backported to #Activity in order to be directly available on all existing instances
    &#34;&#34;&#34;

    def getExchange(self, name=None, input=None, single=True):
        &#34;&#34;&#34;Get exchange by name or input

        Parameters
        ----------
        name : name of the exchange. Name can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffised by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

        single :True if a single match is expected. Otherwize, a list of result is returned

        Returns
        -------
            Single exchange or list of exchanges (if _single is False or &#34;name&#34; contains a &#39;*&#39;)
            raise Exception if not matching exchange found
        &#34;&#34;&#34;

        def single_match(name, exch) :

            # Name can be &#34;Elecricity#RER&#34;
            if &#34;#&#34; in name:
                name, loc = name.split(&#34;#&#34;)
                negative = False
                if loc.startswith(&#34;!&#34;) :
                    negative = True
                    loc = loc[1:]
                act = getActByCode(*exch[&#39;input&#39;])

                if not &#39;location&#39; in act or (negative and act[&#39;location&#39;] == loc) or (not negative and act[&#39;location&#39;] != loc) :
                    return False

            if &#39;*&#39; in name :
                name = name.replace(&#39;*&#39;, &#39;&#39;)
                return name in exch[&#39;name&#39;]
            else :
                return name == exch[&#39;name&#39;]


        def match(exch):
            if name :
                if isinstance(name, list):
                    return any(single_match(iname, exch) for iname in name)
                else:
                    return single_match(name, exch)

            if input:
                return input == exch[&#39;input&#39;]

        exchs = list(exch for exch in self.exchangesNp() if match(exch))
        if len(exchs) == 0:
            raise Exception(&#34;Found no exchange matching name : %s&#34; % name)

        if single and len(exchs) != 1:
            raise Exception(&#34;Expected 1 exchange with name &#39;%s&#39; found %d&#34; % (name, len(exchs)))
        if single:
            return exchs[0]
        else:
            return exchs

    def setOutputAmount(self, amount):
        &#39;&#39;&#39;Set the amount for the single output exchange (1 by default)&#39;&#39;&#39;
        self.addExchanges({self : amount})

    def updateExchanges(self, updates: Dict[str, any] = dict()):
        &#34;&#34;&#34;Update existing exchanges, by name.

        Parameters
        ----------
        updates : Dict of &#34;&lt;exchange name&gt;&#34; =&gt; &lt;new value&gt;

            &lt;exchange name&gt; can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffixed by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

            &lt;New Value&gt;  : either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
            or dict of attributes, for updating both at once, or any other attribute.
            The amount can reference the symbol &#39;old_amount&#39; that will be replaced with the current amount of the exchange.
        &#34;&#34;&#34;

        # Update exchanges
        for name, attrs in updates.items():

            exchs = self.getExchange(name, single=not &#39;*&#39; in name)
            if not isinstance(exchs, list):
                exchs = [exchs]
            for exch in exchs:

                if attrs is None:
                    exch.delete()
                    exch.save()
                    continue

                # Single value ? =&gt; amount
                if not isinstance(attrs, dict):
                    if isinstance(attrs, Activity):
                        attrs = dict(input=attrs)
                    else :
                        attrs = dict(amount=attrs)

                if &#39;amount&#39; in attrs:
                    attrs.update(_amountToFormula(attrs[&#39;amount&#39;], exch[&#39;amount&#39;]))

                exch.update(attrs)
                exch.save()

                # We have a formula now ? =&gt; register it to parametrized exchange
                if &#39;formula&#39; in attrs:
                    bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def deleteExchanges(self, name, single=True):
        &#39;&#39;&#39; Remove matching exchanges &#39;&#39;&#39;
        exchs = self.getExchange(name, single=single)
        if not isinstance(exchs, list):
            exchs = [exchs]
        if len(exchs) == 0 :
            raise Exception(&#34;No exchange found for &#39;%s&#39;&#34; % name)
        for ex in exchs :
            ex.delete()
            ex.save()
        self.save()

    def substituteWithDefault(self, exchange_name: str, switch_act: Activity, paramSwitch: EnumParam, amount=None):

        &#34;&#34;&#34;Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
        For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by &#39;&lt;param_name&gt;_default&#39;,
        making it null as soon as one enum value is set.

        This is useful for changing electricty mix, leaving the default one if needed

        Parameters
        ----------
        act : Activity to update
        exchange_name : Name of the exchange to update
        switch_act : Activity to substitue as input
        amount : Amount of the input (uses previous amount by default)
        &#34;&#34;&#34;

        current_exch = self.getExchange(exchange_name)

        prev_amount = amount if amount else _getAmountOrFormula(current_exch)

        self.addExchanges({switch_act: prev_amount})
        self.updateExchanges({exchange_name: paramSwitch.symbol(None) * prev_amount})

    def addExchanges(self, exchanges: Dict[Activity, Union[NumOrExpression, dict]] = dict()):
        &#34;&#34;&#34;Add exchanges to an existing activity, with a compact syntax :

        Parameters
        ----------
        exchanges : Dict of activity =&gt; amount or activity =&gt; attributes_dict. \
            Amount being either a fixed value or Sympy expression (arithmetic expression of Sympy symbols)
        &#34;&#34;&#34;
        parametrized = False
        for sub_act, attrs in exchanges.items():

            if isinstance(attrs, dict):
                amount = attrs.pop(&#39;amount&#39;)
            else:
                amount = attrs
                attrs = dict()

            exch = self.new_exchange(
                input=sub_act.key,
                name=sub_act[&#39;name&#39;],
                unit=sub_act[&#39;unit&#39;] if &#39;unit&#39; in sub_act else None,
                type=&#39;production&#39; if self == sub_act else &#39;biosphere&#39; if sub_act[&#39;database&#39;] == BIOSPHERE3_DB_NAME else &#39;technosphere&#39;)

            exch.update(attrs)
            exch.update(_amountToFormula(amount))
            if &#39;formula&#39; in exch:
                parametrized = True

            exch.save()
        self.save()
        if parametrized:
            bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def getAmount(self, *args, sum=False, **kargs):
        &#34;&#34;&#34;
        Get the amount of one or several exchanges, selected by name or input. See #getExchange()
        &#34;&#34;&#34;
        exchs = self.getExchange(*args, single=not sum, **kargs)
        if sum:
            res = 0
            if len(exchs) == 0:
                raise Exception(&#34;No exchange found&#34;)
            for exch in exchs:
                res += _getAmountOrFormula(exch)
            return res
        else:
            return _getAmountOrFormula(exchs)

    def exchangesNp(self):
        &#34;&#34;&#34; List of exchange, except production (output) one.&#34;&#34;&#34;
        for exch in self.exchanges():
            if exch[&#39;input&#39;] != exch[&#39;output&#39;]:
                yield exch


# Backport new methods to vanilla Activity class in order to benefit from it for all existing instances
for name, item in ActivityExtended.__dict__.items():
    if isinstance(item, types.FunctionType):
        setattr(Activity, name, item)


def _eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def _isnumber(value):
    return isinstance(value, int) or isinstance(value, float)


def printAct(*activities,  **params):
    &#34;&#34;&#34;
    Print activities and their exchanges.
    If parameter values are provided, formulas will be evaluated accordingly
    &#34;&#34;&#34;
    tables = []
    names = []

    for act in activities:
        df = pd.DataFrame(index=[&#39;input&#39;, &#39;amount&#39;, &#39;unit&#39;, &#39;type&#39;])
        data = dict()
        for (i, exc) in enumerate(act.exchanges()):
            input = bw.get_activity(exc.input.key)
            amount = _getAmountOrFormula(exc)

            # Params provided ? Evaluate formulas
            if len(params) &gt; 0 and isinstance(amount, Basic):
                new_params = [(name, value) for name, value in _completeParamValues(params).items()]
                amount = amount.subs(new_params)

            name = exc[&#39;name&#39;]
            if &#39;location&#39; in input and input[&#39;location&#39;] != &#34;GLO&#34;:
                name += &#34;#%s&#34; % input[&#39;location&#39;]
            if exc.input.key[0] not in [BIOSPHERE3_DB_NAME, ECOINVENT_DB_NAME] :
                name += &#34; {user-db}&#34;

            iname = name
            i=1
            while iname in data :
                iname = &#34;%s#%d&#34; % (name, i)
                i += 1

            data[iname] = [str(input), amount, exc.unit, exc[&#39;type&#39;]]

        for key, values in data.items() :
            df[key] = values

        tables.append(df.T)
        names.append(_actDesc(act))

    full = pd.concat(tables, axis=1, keys=names, sort=True)

    if len(activities) == 2 :
        yellow = &#34;background-color:yellow&#34;
        iamount1 = full.columns.get_loc((names[0], &#34;amount&#34;))
        iamount2 = full.columns.get_loc((names[1], &#34;amount&#34;))
        iact1 = full.columns.get_loc((names[0], &#34;input&#34;))
        iact2 = full.columns.get_loc((names[1], &#34;input&#34;))
        def same_amount(row) :
            res = [&#34;&#34;] * len(row)

            if row[iamount1] != row[iamount2] :
                res[iamount1] = yellow
                res[iamount2] = yellow
            if row[iact1] != row[iact2]:
                res[iact1] = yellow
                res[iact2] = yellow
            return res

        full = full.style.apply(same_amount, axis=1)

    display(full)



def resetDb(db_name):
    &#34;&#34;&#34; Create or cleanup a user DB&#34;&#34;&#34;
    if db_name in bw.databases:
        _eprint(&#34;Db %s was here. Reseting it&#34; % db_name)
        del bw.databases[db_name]
    db = bw.Database(db_name)
    db.write(dict())


def importDb(dbname, path):
    &#39;&#39;&#39;Import eco invent DB&#39;&#39;&#39;

    if dbname in bw.databases:
        _eprint(&#34;Database &#39;%s&#39; has already been imported &#34; % dbname)
    else:
        ei34 = bw.SingleOutputEcospold2Importer(path, dbname)
        ei34.apply_strategies()
        ei34.statistics()
        ei34.write_database()


dbs = dict()

def _getDb(dbname) -&gt; bw.Database:
    &#34;&#34;&#34;Pool of Database instances&#34;&#34;&#34;
    if not dbname in dbs:
        dbs[dbname] = bw.Database(dbname)
    return dbs[dbname]


def resetParams(db_name):
    &#34;&#34;&#34;Reset project and activity parameters&#34;&#34;&#34;
    _param_registry().clear()
    ProjectParameter.delete().execute()
    ActivityParameter.delete().execute()
    DatabaseParameter.delete().execute()
    Group.delete().execute()


# Index of activities per name, for fast search dict[db_name][activity_word] =&gt; list of activitites
db_index = dict()


def _split_words(name):
    clean = re.sub(&#39;[^0-9a-zA-Z]+&#39;, &#39; &#39;, name)
    clean = re.sub(&#39; +&#39;, &#39; &#39;, clean)
    clean = clean.lower()

    return clean.split(&#39; &#39;)


def _build_index(db):
    res = defaultdict(set)
    for act in db:
        words = _split_words(act[&#39;name&#39;])
        for word in words:
            res[word].add(act)
    return res


def _get_indexed_db(db_name):
    if not db_name in db_index:
        db_index[db_name] = _build_index(_getDb(db_name))
    return db_index[db_name]


def _find_candidates(db_name, name):

    res = []
    index = _get_indexed_db(db_name)
    words = _split_words(name)
    for word in words:
        candidates = index[word]
        if len(res) == 0 or (0 &lt; len(candidates) &lt; len(res)):
            res = list(candidates)
    return res


def getActByCode(db_name, code):
    &#34;&#34;&#34; Get activity by code &#34;&#34;&#34;
    return _getDb(db_name).get(code)


def findActivity(name=None, loc=None, in_name=None, code=None, categories=None, category=None, db_name=None,
                 single=True, unit=None):
    &#34;&#34;&#34;
        Find single activity by name &amp; location
        Uses index for fast fetching
    &#34;&#34;&#34;

    if name and &#39;*&#39; in name :
        in_name = name.replace(&#34;*&#34;, &#34;&#34;)
        name = None

    def act_filter(act):
        if name and not name == act[&#39;name&#39;]:
            return False
        if in_name and not in_name in act[&#39;name&#39;]:
            return False
        if loc and not loc == act[&#39;location&#39;]:
            return False
        if unit and not unit == act[&#39;unit&#39;] :
            return False
        if category and not category in act[&#39;categories&#39;]:
            return False
        if categories and not tuple(categories) == act[&#39;categories&#39;]:
            return False
        return True

    if code:
        acts = [getActByCode(db_name, code)]
    else:
        name_key = name if name else in_name

        # Find candidates via index
        candidates = _find_candidates(db_name, name_key)

        # Exact match
        acts = list(filter(act_filter, candidates))

    if single and len(acts) == 0:
        raise Exception(&#34;No activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;&#34; % (db_name, name, loc))
    if single and len(acts) &gt; 1:
        raise Exception(&#34;Several activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;:\n%s&#34; % (
        db_name, name, loc, str(acts)))
    if len(acts) == 1:
        return acts[0]
    else:
        return acts


def findBioAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=BIOSPHERE3_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=BIOSPHERE3_DB_NAME, **kwargs)


def findTechAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=ECOINVENT_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=ECOINVENT_DB_NAME, **kwargs)


def interpolate(x, x1, x2, y1, y2):
    &#34;&#34;&#34;Build an expression for linear interpolation between two points&#34;&#34;&#34;
    return y1 + (y2 - y1) * (x - x1) / (x2 - x1)


def newInterpolatedAct(dbname: str, name: str, act1: ActivityExtended, act2: ActivityExtended, x1, x2, x, alpha1=1, alpha2=1, **kwargs):

    &#34;&#34;&#34;Creates a new activity made of interpolation of two similar activities.
    For each exchange :
    amount = alpha1 * a1 + (x - X1) * (alpha2 * a2 - alpha1 * a1) / (x2 - x1)

    Parameters
    ----------
    name : Name of new activity
    act1 : Activity 1
    act2 : Activity 2
    x1 : X for act1
    x2 : X for act 2
    x : Should be a parameter symbol
    alpha1 : Ratio for act1 (Default value = 1)
    alpha2 : Ratio for act2 (Default value = 1)
    kwargs : Any other param will be added as attributes of new activity
    &#34;&#34;&#34;
    res = copyActivity(dbname, act1, name, withExchanges=False, **kwargs)

    exch1_by_input = dict({exch[&#39;input&#39;]: exch for exch in act1.exchangesNp()})
    exch2_by_input = dict({exch[&#39;input&#39;]: exch for exch in act2.exchangesNp()})

    inputs = set(chain(exch1_by_input.keys(), exch2_by_input.keys()))

    for input in inputs:

        exch1 = exch1_by_input.get(input)
        exch2 = exch2_by_input.get(input)
        exch = exch1 if exch1 else exch2

        amount1 = exch1[&#39;amount&#39;] if exch1 else 0
        amount2 = exch2[&#39;amount&#39;] if exch2 else 0

        if exch1 and exch2 and exch1[&#39;name&#39;] != exch2[&#39;name&#39;]:
            raise Exception(&#34;Input %s refer two different names : %s, %s&#34; % (input, exch1[&#39;name&#39;], exch2[&#39;name&#39;]))

        amount = interpolate(x, x1, x2, amount1 * alpha1, amount2 * alpha2)
        act = getActByCode(*input)
        res.addExchanges({act: dict(amount=amount, name=exch[&#39;name&#39;])})
    return res




def newParamDef(name, type, **kwargs):
    &#34;&#34;&#34;Creates a param and register it into a global registry and as a brightway parameter&#34;&#34;&#34;
    if type == ParamType.ENUM:
        param = EnumParam(name, **kwargs)
    elif type == ParamType.BOOL :
        param = BooleanDef(name, **kwargs)
    else:
        param = ParamDef(name, type=type, **kwargs)

    # Put it in local registry (in memory)
    if name in _param_registry():
        _eprint(&#34;Param %s was already defined : overriding&#34; % name)
    _param_registry()[name] = param

    # Save in brightway2 project
    bwParams = [dict(name=key, amount=value) for key, value in param.expandParams().items()]
    bw.parameters.new_project_parameters(bwParams)

    return param


def newFloatParam(name, default, **kwargs):
    return newParamDef(name, ParamType.FLOAT, default=default, **kwargs)

def newBoolParam(name, default, **kwargs):
    return newParamDef(name, ParamType.BOOL, default=default, **kwargs)

def newEnumParam(name, default, **kwargs):
    return newParamDef(name, ParamType.ENUM, default=default, **kwargs)


def _amountToFormula(amount: Union[float, str, Basic], currentAmount=None):
    &#34;&#34;&#34;Transform amount in exchange to either simple amount or formula&#34;&#34;&#34;
    res = dict()
    if isinstance(amount, Basic):

        if currentAmount != None:
            amount = amount.subs(old_amount, currentAmount)

        # Check the expression does not reference undefined params
        all_symbols = list([key for param in _param_registry().values() for key, val in param.expandParams().items()])
        for symbol in amount.free_symbols:
            if not str(symbol) in all_symbols:
                raise Exception(&#34;Symbol &#39;%s&#39; not found in params : %s&#34; % (symbol, all_symbols))

        res[&#39;formula&#39;] = str(amount)
        res[&#39;amount&#39;] = 0
    elif isinstance(amount, float) or isinstance(amount, int):
        res[&#39;amount&#39;] = amount
    else:
        raise Exception(
            &#34;Amount should be either a constant number or a Sympy expression (expression of ParamDef). Was : %s&#34; % type(
                amount))
    return res



def _getAmountOrFormula(ex: ExchangeDataset) -&gt; Union[Basic, float]:
    &#34;&#34;&#34; Return either a fixed float value or an expression for the amount of this exchange&#34;&#34;&#34;
    if &#39;formula&#39; in ex:
        try:
            return parse_expr(ex[&#39;formula&#39;])
        except:
            _eprint(&#34;Error while parsing formula &#39;%s&#39; : backing to amount&#34; % ex[&#39;formula&#39;])

    return ex[&#39;amount&#39;]





def _newAct(db_name, code):

    db = _getDb(db_name)
    # Already present : delete it ?
    for act in db:
        if act[&#39;code&#39;] == code:
            _eprint(&#34;Activity &#39;%s&#39; was already in &#39;%s&#39;. Overwriting it&#34; % (code, db_name))
            act.delete()

    return db.new_activity(code)



def newActivity(db_name, name, unit,
        exchanges: Dict[Activity, Union[float, str]] = dict(),
        code=None,
        **argv):
    &#34;&#34;&#34;Creates a new activity

    Parameters
    ----------
    name : Name ofthe new activity
    db_name : Destination DB : ACV DB by default
    exchanges : Dict of activity =&gt; amount. If amount is a string, is it considered as a formula with parameters
    argv : extra params passed as properties of the new activity
    &#34;&#34;&#34;
    act = _newAct(db_name, code if code else name)
    act[&#39;name&#39;] = name
    act[&#39;type&#39;] = &#39;process&#39;
    act[&#39;unit&#39;] = unit
    act.update(argv)

    # Add exchanges
    act.addExchanges(exchanges)

    return act


def copyActivity(db_name, activity: ActivityExtended, code=None , withExchanges=True, **kwargs) -&gt; ActivityExtended:
    &#34;&#34;&#34;Copy activity into a new DB&#34;&#34;&#34;

    res = _newAct(db_name, code)

    for key, value in activity.items():
        if key not in [&#39;database&#39;, &#39;code&#39;]:
            res[key] = value
    for k, v in kwargs.items():
        res._data[k] = v
    res._data[u&#39;code&#39;] = code
    res[&#39;name&#39;] = code
    res.save()

    if withExchanges:
        for exc in activity.exchanges():
            data = deepcopy(exc._data)
            data[&#39;output&#39;] = res.key
            # Change `input` for production exchanges
            if exc[&#39;input&#39;] == exc[&#39;output&#39;]:
                data[&#39;input&#39;] = res.key
            ExchangeDataset.create(**dict_as_exchangedataset(data))

    return res



def newSwitchAct(dbname, name, paramDef: ParamDef, acts_dict: Dict[str, Activity]):
    &#34;&#34;&#34;Create a new parametrized, virtual activity, made of a map of other activities, controlled by an enum parameter.
    This enables to implement a &#34;Switch&#34; with brightway parameters
    Internally, this will create a linear sum of other activities controlled by &lt;param_name&gt;_&lt;enum_value&gt; : 0 or 1

    Parameters
    ----------
    paramDef : parameter definition of type enum
    acts_dict : dict of &lt;enumValue&gt; =&gt; activity
    &#34;&#34;&#34;

    # Transform map of enum values to correspoding formulas &lt;param_name&gt;_&lt;enum_value&gt;
    exch = {act: paramDef.symbol(key) for key, act in acts_dict.items()}
    res = newActivity(
        dbname,
        name,
        unit=list(acts_dict.values())[0][&#39;unit&#39;],
        exchanges=exch)


    # Unit of switch activity is the one of the children
    for key, act in acts_dict.items():
        if &#39;unit&#39; in act:
            res[&#39;unit&#39;] = act[&#39;unit&#39;]
            res.save()
    return res


def _actName(act: Activity):
    &#34;&#34;&#34;Generate pretty name for activity, appending location if not &#39;GLO&#39; &#34;&#34;&#34;
    res = act[&#39;name&#39;]
    if act[&#39;location&#39;] != &#39;GLO&#39;:
        res += &#34;[%s]&#34; % act[&#34;location&#34;]
    return res

def _actDesc(act: Activity):
    &#34;&#34;&#34;Generate pretty name for activity + basic information &#34;&#34;&#34;
    name = _actName(act)
    amount = 1
    for ex in act.exchanges() :
        if ex[&#39;type&#39;] == &#39;production&#39; :
            amount = ex[&#39;amount&#39;]

    return &#34;%s (%f %s)&#34; % (name, amount, act[&#39;unit&#39;])

def _multiLCA(activities, methods):
    &#34;&#34;&#34;Simple wrapper around brightway API&#34;&#34;&#34;
    bw.calculation_setups[&#39;process&#39;] = {&#39;inv&#39;: activities, &#39;ia&#39;: methods}
    lca = bw.MultiLCA(&#39;process&#39;)
    cols = [_actName(act) for act_amount in activities for act, amount in act_amount.items()]
    return pd.DataFrame(lca.results.T, index=[method_name(method) for method in methods], columns=cols)


def _listOfDictToDictOflist(LD):
    return {k: [dic[k] for dic in LD] for k in LD[0]}


def _completeParamValues(params):
    &#34;&#34;&#34;Check parameters and expand enum params.

    Returns
    -------
        Dict of param_name =&gt; float value
    &#34;&#34;&#34;

    # undef_params = param_registry.keys() - params.keys()
    # if undef_params :
    #    raise Exception(&#34;Some model parameters are not set : %s&#34; % undef_params)

    res = dict()
    for key, val in params.items():
        if key in _param_registry():
            param = _param_registry()[key]
        else:
            raise Exception(&#34;Parameter not found : %s. Valid parameters : %s&#34; % (key, list(_param_registry().keys())))

        if isinstance(val, list):
            newvals = [param.expandParams(val) for val in val]
            res.update(_listOfDictToDictOflist(newvals))
        else:
            res.update(param.expandParams(val))
    return res


def multiLCA(model, methods, **params):
    &#34;&#34;&#34;Compute LCA for a single activity and a set of methods, after settings the parameters and updating exchange amounts.

    Parameters
    ----------
    model : Single activity (root model) or list of activities
    methods : Impact methods to consider
    params : Other parameters of the model
    &#34;&#34;&#34;

    # Check and expand params
    params = _completeParamValues(params)

    # Update brightway parameters
    bwParams = [dict(name=key, amount=value) for key, value in params.items()]
    bw.parameters.new_project_parameters(bwParams)

    # ActivityParameter.recalculate_exchanges(DEFAULT_PARAM_GROUP)
    bw.parameters.recalculate()

    if isinstance(model, list):
        activities = [{act: 1} for act in model]
    else:
        activities = [{model: 1}]
    return _multiLCA(activities, methods).transpose()




def preMultiLCAAlgebric(model:ActivityExtended, methods, param_names=None, amount=1) :
    &#39;&#39;&#39;
        This method transforms an activity into a set of functions ready to compute LCA very fast on a set on methods.
        You may use is and pass the result to postMultiLCAAlgebric for fast computation on a model that does not change.

        This method is used by multiLCAAlgebric
    &#39;&#39;&#39;

    # print(&#34;computing model to expression for %s&#34; % model)
    expr, actBySymbolName = actToExpression(model)

    dbname = model.key[0]

    param_names = _expand_param_names(param_names)

    # Check missing params
    free_names = set([str(symb) for symb in expr.free_symbols])
    act_names = set([str(symb) for symb in actBySymbolName.keys()])
    expected_names  = free_names - act_names
    missing_names = expected_names - set(param_names)

    if len(missing_names) &gt; 0 :
        raise Exception(&#39;Missing parameter of the model : %s&#39; % str(missing_names))

    debug(param_names)

    for name in param_names :
        registry_names = _expand_param_names(_param_registry())
        if name not in registry_names :
            raise Exception(&#39;Model refers to unknown param &#34;%s&#34;&#39; % name)

    # Create dummy reference to biosphere
    # We cannot run LCA to biosphere activities
    # We create a technosphere activity mapping exactly to 1 biosphere item
    pureTechActBySymbol = OrderedDict()
    for name, act in actBySymbolName.items():
        if act[0] == BIOSPHERE3_DB_NAME:
            act = _getOrCreateDummyBiosphereActCopy(dbname, act[1])
        else:
            act = getActByCode(*act)
        pureTechActBySymbol[name] = act

    # List of activities, ordered
    acts = pureTechActBySymbol.values()

    # Transform to [{act1:1], {act2:1}, etc] for MultiLCA
    actsWithAmount = [{act: 1} for act in acts]

    # Compute LCA for all background activities and methods
    lca = _multiLCA(actsWithAmount, methods)

    # For each method, compute an algebric expression with activities replaced by their values
    lambdas = []
    for imethod, method in enumerate(methods):
        # print(&#34;Generating lamba function for %s / %s&#34; % (model, method))

        # Replace activities by their value in expression for this method
        sub = dict({symbol: lca.iloc[imethod, iact] for iact, symbol in enumerate(pureTechActBySymbol.keys())})
        method_expr = expr.xreplace(sub)

        # Tranform Sympy expression to lambda function, based on numpy to fast vectorial evaluation
        lambd = lambdify(param_names, method_expr, &#39;numpy&#39;)
        lambdas.append(lambd)

    return lambdas

def method_name(method) :
    return method[1] + &#34; - &#34; + method[2]

def postMultiLCAAlgebric(methods, lambdas, alpha=1, **params):
    &#39;&#39;&#39;
        Compute LCA for a given set of parameters and pre-compiled lambda functions.
        This function is used by **multiLCAAlgebric**

        Parameters
        ----------
        methodAndLambdas : Output of preMultiLCAAlgebric
        **params : Parameters of the model
    &#39;&#39;&#39;

    # Check and expand params
    params = _completeParamValues(params)

    # Expand parameters as list of parameters
    param_length = 1

    for key, val in params.items():
        if isinstance(val, list):
            if param_length == 1:
                param_length = len(val)
            elif param_length != len(val):
                raise Exception(&#34;Parameters should be a single value or a list of same number of values&#34;)

    # Expand params and transform lists to np.array for vector computation
    for key in params.keys():
        val = params[key]
        if not isinstance(val, list):
            val = list([val] * param_length)
        params[key] = np.array(val)


    res = np.zeros((len(methods), param_length))

    # Compute result on whole vectors of parameter samples at a time : lambdas use numpy for vector computation
    for imethod, lambd in enumerate(lambdas):
        res[imethod, :] = alpha * lambd(**params)

    return pd.DataFrame(res, index=[method_name(method) for method in methods]).transpose()

def _expand_param_names(param_names) :
    &#39;&#39;&#39;Expand parameters names (with enum params) &#39;&#39;&#39;
    return [name for key in param_names for name in _param_registry()[key].names()]

def multiLCAAlgebric(models, methods, **params):
    &#34;&#34;&#34;Compute LCA by expressing the foreground model as symbolic expression of background activities and parameters.
    Then, compute &#39;static&#39; inventory of the referenced background activities.
    This enables a very fast recomputation of LCA with different parameters, useful for stochastic evaluation of parametrized model

    Parameters
    ----------
    models : Single model or list of models or dict of model:amount : if list of models, you cannot use param lists
    methods : List of methods / impacts to consider
    params : You should provide named values of all the parameters declared in the model. \
             Values can be single value or list of samples, all of the same size
    &#34;&#34;&#34;
    dfs = dict()

    if not isinstance(models, list):
        models = [models]

    for model in models:

        alpha = 1
        if type(model) is tuple :
            model, alpha=model

        lambdas = preMultiLCAAlgebric(model, methods, params.keys())

        df = postMultiLCAAlgebric(methods, lambdas, alpha=alpha, **params)

        model_name = _actName(model)

        # Single params ? =&gt; give the single row the name of the model activity
        if df.shape[0] == 1:
            df = df.rename(index={0: model_name})

        dfs[model_name] = df

    if len(dfs) == 1:
        df = list(dfs.values())[0]
        return df
    else:
        # Concat several dataframes for several models
        return pd.concat(list(dfs.values()))


def _getOrCreateDummyBiosphereActCopy(dbname, code):
    &#34;&#34;&#34;
        We cannot reference directly biosphere in the model, since LCA can only be applied to products
        We create a dummy activity in our DB, with same code, and single exchange of amount &#39;1&#39;
    &#34;&#34;&#34;

    code_to_find = code + &#34;#asTech&#34;
    try:
        return _getDb(dbname).get(code_to_find)
    except:
        bioAct = _getDb(BIOSPHERE3_DB_NAME).get(code)
        name = bioAct[&#39;name&#39;] + &#39; # asTech&#39;
        res = newActivity(dbname, name, bioAct[&#39;unit&#39;], {bioAct: 1}, code=code_to_find)
        return res


def actToExpression(act: Activity):
    &#34;&#34;&#34;Computes a symbolic expression of the model, referencing background activities and model parameters as symbols

    Returns
    -------
        (sympy_expr, dict of symbol =&gt; activity)
    &#34;&#34;&#34;

    act_symbols = dict()  # Dict of  act = &gt; symbol

    def act_to_symbol(db_name, code):

        act = _getDb(db_name).get(code)
        name = act[&#39;name&#39;]
        base_slug = slugify(name, separator=&#39;_&#39;)

        slug = base_slug
        i = 1
        while symbols(slug) in act_symbols.values():
            slug = f&#34;{base_slug}{i}&#34;
            i += 1

        return symbols(slug)

    def rec_func(act: Activity):

        res = 0
        outputAmount = 1

        for exch in act.exchanges():

            formula = _getAmountOrFormula(exch)

            if isinstance(formula, types.FunctionType):
                # Some amounts in EIDB are functions ... we ignore them
                continue

            input_db, input_code = exch[&#39;input&#39;]

            #  Different output ?
            if exch[&#39;input&#39;] == exch[&#39;output&#39;]:
                if exch[&#39;amount&#39;] != 1:
                    outputAmount = exch[&#39;amount&#39;]
                continue

            # Background DB =&gt; reference it as a symbol
            if input_db in [BIOSPHERE3_DB_NAME, ECOINVENT_DB_NAME]:
                if not (input_db, input_code) in act_symbols:
                    act_symbols[(input_db, input_code)] = act_to_symbol(input_db, input_code)
                act_expr = act_symbols[(input_db, input_code)]

            # Our model : recursively transform it to a symbolic expression
            else:

                if input_db == act[&#39;database&#39;] and input_code == act[&#39;code&#39;]:
                    raise Exception(&#34;Recursive exchange : %s&#34; % (act.__dict__))

                sub_act = _getDb(input_db).get(input_code)
                act_expr = rec_func(sub_act)

            res += formula * act_expr

        return  res / outputAmount

    expr = rec_func(act)

    return (expr, _reverse_dict(act_symbols))


def _reverse_dict(dic):
    return {v: k for k, v in dic.items()}


def _heatmap(df, title, vmax, ints=False):
    &#39;&#39;&#39; Produce heatmap of a dataframe&#39;&#39;&#39;
    fig, ax = plt.subplots(figsize=(17, 17))
    sns.heatmap(df.transpose(), cmap=&#34;gist_heat_r&#34;, vmax=vmax, annot=True, fmt=&#39;.0f&#39; if ints else &#39;f&#39;, square=True)
    plt.title(title, fontsize=20)
    ax.tick_params(axis=&#34;x&#34;, labelsize=18)
    ax.tick_params(axis=&#34;y&#34;, labelsize=18)


def oat_matrix(model, impacts, n=10) :
    &#39;&#39;&#39;Generates a heatmap of the incertitude of the model, varying input parameters one a a time.&#39;&#39;&#39;

    # Compile model into lambda functions for fast LCA
    lambdas = preMultiLCAAlgebric(model, impacts, _param_registry().keys())

    change = np.zeros((len(_variable_params()), len(impacts)))

    for iparam, param in enumerate(_variable_params().values()) :
        params = {param.name: param.default for param in _param_registry().values()}

        # Compute range of values for given param
        params[param.name] = param.range(n)

        # Compute LCA
        df = postMultiLCAAlgebric(impacts, lambdas, **params)

        # Compute change
        change[iparam] =  (df.max() - df.min()) / df.median() * 100

    # Build final heatmap
    change = pd.DataFrame(change, index=_variable_params().keys(), columns=[imp[2] for imp in impacts])
    _heatmap(change.transpose(), &#39;Change of impacts per variability of the input parameters (%)&#39;, 100, ints=True)


def _method_unit(method) :
    return bw.Method(method).metadata[&#39;unit&#39;]


def _display_tabs(titlesAndContentF) :
    &#39;&#39;&#39;Generate tabs&#39;&#39;&#39;
    tabs = []
    titles= []
    for title, content_f in titlesAndContentF :
        titles.append(title)

        tab = widgets.Output()
        with tab :
            content_f()
        tabs.append(tab)

    res = widgets.Tab(children=tabs)
    for i, title in enumerate(titles) :
        res.set_title(i, title)
    display(res)


def oat_dasboard(modelOrLambdas, impacts, param: ParamDef, n=10) :
    &#39;&#39;&#39;
    Analyse the evolution of impacts for a single parameter. The other parameters are set to their default values.

    Parameters
    ----------
    model : activity, or lambdas as precomputed by preMultiLCAAlgebric, for faster computation
    impacts : set of methods
    param: parameter to analyse
    n: number of samples of the parameter
    &#39;&#39;&#39;

    params = {param.name : param.default for param in _param_registry().values()}

    # Compute range of values for given param
    params[param.name] = param.range(n)


    #print(&#34;Params: &#34;, params)

    if isinstance(modelOrLambdas, Activity) :
        df = multiLCAAlgebric(modelOrLambdas, impacts, **params)
    else :
        df = postMultiLCAAlgebric(impacts, modelOrLambdas, **params)

    # Add X values in the table
    pname = param.name
    if param.unit :
        pname = &#39;%s [%s]&#39; % (pname, param.unit)
    df.insert(0, pname, param.range(n))
    df = df.set_index(pname)


    def table() :
        display(df)

    def graph() :

        with warnings.catch_warnings():

            warnings.simplefilter(&#34;ignore&#34;)

            nb_rows = len(impacts) // 3 + 1

            fig, axes = plt.subplots(figsize=(15, 15))

            axes = df.plot(
                ax=axes, sharex=True, subplots=True,
                layout=(nb_rows, 3),
                #legend=None,
                kind = &#39;line&#39; if param.type == ParamType.FLOAT else &#39;bar&#39;)

            axes = axes.flatten()

            for ax, impact in zip(axes, impacts) :
                ax.set_ylim(ymin=0)
                ax.set_ylabel(_method_unit(impact))

            plt.show(fig)

    def change() :

        ch = (df.max() - df.min()) / df.median() * 100
        fig, ax = plt.subplots(figsize=(9, 6))
        plt.title(&#39;Relative change for %s&#39; % df.index.name)
        ch.plot(kind=&#39;barh&#39;, rot=30)
        ax.set_xlabel(&#39;Relative change of the median value (%)&#39;)
        plt.tight_layout()
        plt.show(fig)

    _display_tabs([
        (&#34;Graphs&#34;, graph),
        (&#34;Data&#34;, table),
        (&#34;Variation&#34;, change)
    ])


def oat_dashboard_interact(model, methods):
    &#39;&#39;&#39;Interative dashboard, with a dropdown for selecting parameter&#39;&#39;&#39;

    lambdas = preMultiLCAAlgebric(model, methods, _param_registry().keys())

    def process_func(param) :
        oat_dasboard(lambdas, methods, _param_registry()[param])

    paramlist = list(_variable_params().keys())
    interact(process_func, param=paramlist)


def _stochastics(modelOrLambdas, methods, n=1000) :

    &#39;&#39;&#39; Compute stochastic impacts for later analysis of incertitude &#39;&#39;&#39;

    # Extract variable names
    param_names = list(_variable_params().keys())
    problem = {
        &#39;num_vars&#39;: len(param_names),
        &#39;names&#39;: param_names,
        &#39;bounds&#39;: [[0, 1]] * len(param_names)
    }

    print(&#34;Generating samples ...&#34;)
    X = saltelli.sample(problem, n, calc_second_order=True)

    # Map normalized 0-1 random values into real values
    print(&#34;Transforming samples ...&#34;)
    params = dict()
    for i, param_name in enumerate(param_names) :
        param = _param_registry()[param_name]
        vals = list(map(lambda v : param.rand(v), X[:, i]))
        params[param_name] = vals

    # Add static parameters
    for param in _fixed_params().values() :
        params[param.name] = param.default

    print(&#34;Processing LCA ...&#34;)
    if isinstance(modelOrLambdas, Activity):
        Y = multiLCAAlgebric(modelOrLambdas, methods, **params)
    else:
        Y = postMultiLCAAlgebric(methods, modelOrLambdas, **params)

    return problem, X, Y


def _variable_params():
    return {key : param for key, param in _param_registry().items() if param.distrib != DistributionType.FIXED}

def _fixed_params():
    return {key : param for key, param in _param_registry().items() if param.distrib == DistributionType.FIXED}

def _sobols(methods, problem, Y) :
    &#39;&#39;&#39; Computes sobols indices&#39;&#39;&#39;
    s1 = np.zeros((len(problem[&#39;names&#39;]), len(methods)))
    st = np.zeros((len(problem[&#39;names&#39;]), len(methods)))

    for i, method in enumerate(methods) :

        try:
            y = Y[Y.columns[i]]
            res = sobol.analyze(problem, y.to_numpy(), calc_second_order=True)
            st[:, i] = res[&#34;ST&#34;]
            s1[:, i] = res[&#34;S1&#34;]

        except Exception as e:
            error(&#34;Sobol failed on %s&#34; % method[2], e)
    return (s1, st)

def _incer_stochastic_matrix(methods, param_names, Y, st):

    &#39;&#39;&#39; Internal method computing matrix of parameter importance &#39;&#39;&#39;
    def draw(mode) :

        if mode == &#39;sobol&#39; :
            data = st
        else :
            # If percent, express result as percentage of standard deviation / mean
            data = np.zeros((len(param_names), len(methods)))
            for i, method in enumerate(methods):
                # Total variance
                var = np.var(Y[Y.columns[i]])
                mean = np.mean(Y[Y.columns[i]])
                if mean != 0 :
                    data[:, i] = np.sqrt((st[:, i] * var)) / mean * 100


        df = pd.DataFrame(data, index=param_names, columns=[method_name(method) for method in methods])
        _heatmap(
            df.transpose(),
            title=&#34;Relative deviation of impacts (%)&#34; if mode == &#39;percent&#39; else &#34;Sobol indices (part of variability)&#34;,
            vmax=100 if mode == &#39;percent&#39; else 1,
            ints= mode == &#39;percent&#39;)

    interact(draw, mode=[(&#39;Raw sobol indices (ST)&#39;, &#39;sobol&#39;), (&#39;Deviation (ST) / mean&#39;, &#39;percent&#39;)])


def incer_stochastic_matrix(modelOrLambdas, methods, n=1000):
    &#39;&#39;&#39; Method computing matrix of parameter importance &#39;&#39;&#39;

    problem, X, Y = _stochastics(modelOrLambdas, methods, n)

    print(&#34;Processing Sobol indices ...&#34;)
    s1, st = _sobols(methods, problem, Y)

    _incer_stochastic_matrix(methods, problem[&#39;names&#39;], Y, st)


def _incer_stochastic_violin(methods, Y) :
    &#39;&#39;&#39; Internal method for computing violin graph of impacts &#39;&#39;&#39;

    nb_rows = math.ceil(len(methods) / 3)
    fig, axes = plt.subplots(nb_rows, 3, figsize=(15, 15), sharex=True)

    for imethod, method, ax in zip(range(len(methods)), methods, axes.flatten()) :
        ax.violinplot(Y[Y.columns[imethod]], showmedians=True)
        ax.title.set_text(method_name(method))
        ax.set_ylim(ymin=0)
        ax.set_ylabel(_method_unit(method))

    plt.tick_params(axis=&#39;x&#39;, which=&#39;both&#39;, bottom=False, top=False, labelbottom=False)
    plt.show(fig)

def incer_stochastic_violin(modelOrLambdas, methods, n=1000):

    &#39;&#39;&#39; Method for computing violin graph of impacts &#39;&#39;&#39;

    problem, X, Y = _stochastics(modelOrLambdas, methods, n)

    _incer_stochastic_violin(methods, Y)

def _incer_stochastic_variations(methods, Y, param_names, sobols1):

    &#39;&#39;&#39; Method for computing violin graph of impacts &#39;&#39;&#39;
    method_names=[method_name(method) for method in methods]

    std = np.std(Y)
    mean = np.mean(Y)

    fig = plt.figure(num=None, figsize=(12, 6), dpi=80, facecolor=&#39;w&#39;, edgecolor=&#39;k&#39;)
    ax = plt.gca()
    tab20b = plt.get_cmap(&#39;tab20b&#39;)
    tab20c = plt.get_cmap(&#39;tab20c&#39;)
    ax.set_prop_cycle(&#39;color&#39;, [tab20b(k) if k &lt; 1 else tab20c(k-1) for k in np.linspace(0, 2, 40)])

    relative_variance_pct =  std*std / (mean*mean) * 100
    totplt = plt.bar(np.arange(len(method_names)), relative_variance_pct, 0.8)

    sum = np.zeros(len(methods))

    plots = [totplt[0]]

    data = np.zeros((len(param_names) + 2, len(methods)))
    data[0, :] = mean
    data[1, :] = std


    for i_param, param_name in enumerate(param_names) :
        s1 = sobols1[i_param, :]
        data[i_param+2, :] = s1

        curr_bar = s1 * relative_variance_pct
        curr_plt = plt.bar(np.arange(len(method_names)), curr_bar, 0.8, bottom=sum)
        sum += curr_bar
        plots.append(curr_plt[0])


    plt.legend(plots, [&#39;Higher order&#39;] + param_names)
    plt.xticks(np.arange(len(method_names)), method_names, rotation=90)
    plt.title(&#34;variance / mean² (%)&#34;)
    plt.show(fig)

    # Show raw data
    rows = [&#34;mean&#34;, &#34;std&#34;] + [&#34;s1(%s)&#34; % param for param in param_names]
    df = pd.DataFrame(data, index=rows, columns=[method_name(method) for method in methods])
    display(df)




def incer_stochastic_dasboard(model, methods, n=1000) :
    &#39;&#39;&#39; Generates a dashboard with several statistics : matrix of parameter incertitude, violin diagrams, ...&#39;&#39;&#39;

    problem, X, Y = _stochastics(model, methods, n)
    param_names = problem[&#39;names&#39;]

    print(&#34;Processing Sobol indices ...&#34;)
    s1, st = _sobols(methods, problem, Y)


    def violin() :
        _incer_stochastic_violin(methods, Y)

    def variation():
        _incer_stochastic_variations(methods, Y, param_names, s1)

    def matrix() :
        _incer_stochastic_matrix(methods, problem[&#39;names&#39;], Y, st)

    _display_tabs([
        (&#34;Violin graphs&#34;, violin),
        (&#34;Impact variations&#34;, variation),
        (&#34;Sobol matrix&#34;, matrix)
    ])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="lca_algebraic.actToExpression"><code class="name flex">
<span>def <span class="ident">actToExpression</span></span>(<span>act)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes a symbolic expression of the model, referencing background activities and model parameters as symbols</p>
<h2 id="returns">Returns</h2>
<pre><code>(sympy_expr, dict of symbol =&gt; activity)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def actToExpression(act: Activity):
    &#34;&#34;&#34;Computes a symbolic expression of the model, referencing background activities and model parameters as symbols

    Returns
    -------
        (sympy_expr, dict of symbol =&gt; activity)
    &#34;&#34;&#34;

    act_symbols = dict()  # Dict of  act = &gt; symbol

    def act_to_symbol(db_name, code):

        act = _getDb(db_name).get(code)
        name = act[&#39;name&#39;]
        base_slug = slugify(name, separator=&#39;_&#39;)

        slug = base_slug
        i = 1
        while symbols(slug) in act_symbols.values():
            slug = f&#34;{base_slug}{i}&#34;
            i += 1

        return symbols(slug)

    def rec_func(act: Activity):

        res = 0
        outputAmount = 1

        for exch in act.exchanges():

            formula = _getAmountOrFormula(exch)

            if isinstance(formula, types.FunctionType):
                # Some amounts in EIDB are functions ... we ignore them
                continue

            input_db, input_code = exch[&#39;input&#39;]

            #  Different output ?
            if exch[&#39;input&#39;] == exch[&#39;output&#39;]:
                if exch[&#39;amount&#39;] != 1:
                    outputAmount = exch[&#39;amount&#39;]
                continue

            # Background DB =&gt; reference it as a symbol
            if input_db in [BIOSPHERE3_DB_NAME, ECOINVENT_DB_NAME]:
                if not (input_db, input_code) in act_symbols:
                    act_symbols[(input_db, input_code)] = act_to_symbol(input_db, input_code)
                act_expr = act_symbols[(input_db, input_code)]

            # Our model : recursively transform it to a symbolic expression
            else:

                if input_db == act[&#39;database&#39;] and input_code == act[&#39;code&#39;]:
                    raise Exception(&#34;Recursive exchange : %s&#34; % (act.__dict__))

                sub_act = _getDb(input_db).get(input_code)
                act_expr = rec_func(sub_act)

            res += formula * act_expr

        return  res / outputAmount

    expr = rec_func(act)

    return (expr, _reverse_dict(act_symbols))</code></pre>
</details>
</dd>
<dt id="lca_algebraic.copyActivity"><code class="name flex">
<span>def <span class="ident">copyActivity</span></span>(<span>db_name, activity, code=None, withExchanges=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Copy activity into a new DB</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copyActivity(db_name, activity: ActivityExtended, code=None , withExchanges=True, **kwargs) -&gt; ActivityExtended:
    &#34;&#34;&#34;Copy activity into a new DB&#34;&#34;&#34;

    res = _newAct(db_name, code)

    for key, value in activity.items():
        if key not in [&#39;database&#39;, &#39;code&#39;]:
            res[key] = value
    for k, v in kwargs.items():
        res._data[k] = v
    res._data[u&#39;code&#39;] = code
    res[&#39;name&#39;] = code
    res.save()

    if withExchanges:
        for exc in activity.exchanges():
            data = deepcopy(exc._data)
            data[&#39;output&#39;] = res.key
            # Change `input` for production exchanges
            if exc[&#39;input&#39;] == exc[&#39;output&#39;]:
                data[&#39;input&#39;] = res.key
            ExchangeDataset.create(**dict_as_exchangedataset(data))

    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.debug"><code class="name flex">
<span>def <span class="ident">debug</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug(*args, **kwargs) :
    if DEBUG :
        print(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def error(*args, **kwargs):
    print(*args, **kwargs, file=stderr)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.findActivity"><code class="name flex">
<span>def <span class="ident">findActivity</span></span>(<span>name=None, loc=None, in_name=None, code=None, categories=None, category=None, db_name=None, single=True, unit=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Find single activity by name &amp; location
Uses index for fast fetching</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findActivity(name=None, loc=None, in_name=None, code=None, categories=None, category=None, db_name=None,
                 single=True, unit=None):
    &#34;&#34;&#34;
        Find single activity by name &amp; location
        Uses index for fast fetching
    &#34;&#34;&#34;

    if name and &#39;*&#39; in name :
        in_name = name.replace(&#34;*&#34;, &#34;&#34;)
        name = None

    def act_filter(act):
        if name and not name == act[&#39;name&#39;]:
            return False
        if in_name and not in_name in act[&#39;name&#39;]:
            return False
        if loc and not loc == act[&#39;location&#39;]:
            return False
        if unit and not unit == act[&#39;unit&#39;] :
            return False
        if category and not category in act[&#39;categories&#39;]:
            return False
        if categories and not tuple(categories) == act[&#39;categories&#39;]:
            return False
        return True

    if code:
        acts = [getActByCode(db_name, code)]
    else:
        name_key = name if name else in_name

        # Find candidates via index
        candidates = _find_candidates(db_name, name_key)

        # Exact match
        acts = list(filter(act_filter, candidates))

    if single and len(acts) == 0:
        raise Exception(&#34;No activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;&#34; % (db_name, name, loc))
    if single and len(acts) &gt; 1:
        raise Exception(&#34;Several activity found in &#39;%s&#39; with name &#39;%s&#39; and location &#39;%s&#39;:\n%s&#34; % (
        db_name, name, loc, str(acts)))
    if len(acts) == 1:
        return acts[0]
    else:
        return acts</code></pre>
</details>
</dd>
<dt id="lca_algebraic.findBioAct"><code class="name flex">
<span>def <span class="ident">findBioAct</span></span>(<span>name=None, loc=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Alias for findActivity(name, &hellip; db_name=BIOSPHERE3_DB_NAME)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findBioAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=BIOSPHERE3_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=BIOSPHERE3_DB_NAME, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.findTechAct"><code class="name flex">
<span>def <span class="ident">findTechAct</span></span>(<span>name=None, loc=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Alias for findActivity(name, &hellip; db_name=ECOINVENT_DB_NAME)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def findTechAct(name=None, loc=None, **kwargs):
    &#34;&#34;&#34;Alias for findActivity(name, ... db_name=ECOINVENT_DB_NAME)
    &#34;&#34;&#34;
    return findActivity(name=name, loc=loc, db_name=ECOINVENT_DB_NAME, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.getActByCode"><code class="name flex">
<span>def <span class="ident">getActByCode</span></span>(<span>db_name, code)</span>
</code></dt>
<dd>
<section class="desc"><p>Get activity by code</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getActByCode(db_name, code):
    &#34;&#34;&#34; Get activity by code &#34;&#34;&#34;
    return _getDb(db_name).get(code)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.importDb"><code class="name flex">
<span>def <span class="ident">importDb</span></span>(<span>dbname, path)</span>
</code></dt>
<dd>
<section class="desc"><p>Import eco invent DB</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def importDb(dbname, path):
    &#39;&#39;&#39;Import eco invent DB&#39;&#39;&#39;

    if dbname in bw.databases:
        _eprint(&#34;Database &#39;%s&#39; has already been imported &#34; % dbname)
    else:
        ei34 = bw.SingleOutputEcospold2Importer(path, dbname)
        ei34.apply_strategies()
        ei34.statistics()
        ei34.write_database()</code></pre>
</details>
</dd>
<dt id="lca_algebraic.incer_stochastic_dasboard"><code class="name flex">
<span>def <span class="ident">incer_stochastic_dasboard</span></span>(<span>model, methods, n=1000)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a dashboard with several statistics : matrix of parameter incertitude, violin diagrams, &hellip;</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incer_stochastic_dasboard(model, methods, n=1000) :
    &#39;&#39;&#39; Generates a dashboard with several statistics : matrix of parameter incertitude, violin diagrams, ...&#39;&#39;&#39;

    problem, X, Y = _stochastics(model, methods, n)
    param_names = problem[&#39;names&#39;]

    print(&#34;Processing Sobol indices ...&#34;)
    s1, st = _sobols(methods, problem, Y)


    def violin() :
        _incer_stochastic_violin(methods, Y)

    def variation():
        _incer_stochastic_variations(methods, Y, param_names, s1)

    def matrix() :
        _incer_stochastic_matrix(methods, problem[&#39;names&#39;], Y, st)

    _display_tabs([
        (&#34;Violin graphs&#34;, violin),
        (&#34;Impact variations&#34;, variation),
        (&#34;Sobol matrix&#34;, matrix)
    ])</code></pre>
</details>
</dd>
<dt id="lca_algebraic.incer_stochastic_matrix"><code class="name flex">
<span>def <span class="ident">incer_stochastic_matrix</span></span>(<span>modelOrLambdas, methods, n=1000)</span>
</code></dt>
<dd>
<section class="desc"><p>Method computing matrix of parameter importance</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incer_stochastic_matrix(modelOrLambdas, methods, n=1000):
    &#39;&#39;&#39; Method computing matrix of parameter importance &#39;&#39;&#39;

    problem, X, Y = _stochastics(modelOrLambdas, methods, n)

    print(&#34;Processing Sobol indices ...&#34;)
    s1, st = _sobols(methods, problem, Y)

    _incer_stochastic_matrix(methods, problem[&#39;names&#39;], Y, st)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.incer_stochastic_violin"><code class="name flex">
<span>def <span class="ident">incer_stochastic_violin</span></span>(<span>modelOrLambdas, methods, n=1000)</span>
</code></dt>
<dd>
<section class="desc"><p>Method for computing violin graph of impacts</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incer_stochastic_violin(modelOrLambdas, methods, n=1000):

    &#39;&#39;&#39; Method for computing violin graph of impacts &#39;&#39;&#39;

    problem, X, Y = _stochastics(modelOrLambdas, methods, n)

    _incer_stochastic_violin(methods, Y)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.interpolate"><code class="name flex">
<span>def <span class="ident">interpolate</span></span>(<span>x, x1, x2, y1, y2)</span>
</code></dt>
<dd>
<section class="desc"><p>Build an expression for linear interpolation between two points</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def interpolate(x, x1, x2, y1, y2):
    &#34;&#34;&#34;Build an expression for linear interpolation between two points&#34;&#34;&#34;
    return y1 + (y2 - y1) * (x - x1) / (x2 - x1)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.method_name"><code class="name flex">
<span>def <span class="ident">method_name</span></span>(<span>method)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def method_name(method) :
    return method[1] + &#34; - &#34; + method[2]</code></pre>
</details>
</dd>
<dt id="lca_algebraic.multiLCA"><code class="name flex">
<span>def <span class="ident">multiLCA</span></span>(<span>model, methods, **params)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute LCA for a single activity and a set of methods, after settings the parameters and updating exchange amounts.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>Single</code> <code>activity</code> (<code>root</code> <code>model</code>) or <code>list</code> of <code>activities</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>methods</code></strong> :&ensp;<code>Impact</code> <code>methods</code> <code>to</code> <code>consider</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Other</code> <code>parameters</code> of <code>the</code> <code>model</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiLCA(model, methods, **params):
    &#34;&#34;&#34;Compute LCA for a single activity and a set of methods, after settings the parameters and updating exchange amounts.

    Parameters
    ----------
    model : Single activity (root model) or list of activities
    methods : Impact methods to consider
    params : Other parameters of the model
    &#34;&#34;&#34;

    # Check and expand params
    params = _completeParamValues(params)

    # Update brightway parameters
    bwParams = [dict(name=key, amount=value) for key, value in params.items()]
    bw.parameters.new_project_parameters(bwParams)

    # ActivityParameter.recalculate_exchanges(DEFAULT_PARAM_GROUP)
    bw.parameters.recalculate()

    if isinstance(model, list):
        activities = [{act: 1} for act in model]
    else:
        activities = [{model: 1}]
    return _multiLCA(activities, methods).transpose()</code></pre>
</details>
</dd>
<dt id="lca_algebraic.multiLCAAlgebric"><code class="name flex">
<span>def <span class="ident">multiLCAAlgebric</span></span>(<span>models, methods, **params)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute LCA by expressing the foreground model as symbolic expression of background activities and parameters.
Then, compute 'static' inventory of the referenced background activities.
This enables a very fast recomputation of LCA with different parameters, useful for stochastic evaluation of parametrized model</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>models</code></strong> :&ensp;<code>Single</code> <code>model</code> or <code>list</code> of <code>models</code> or <code>dict</code> of <code>model</code>:<code>amount</code> : <code>if</code> <code>list</code> of <code>models</code>, <code>you</code> <code>cannot</code> <code>use</code> <code>param</code> <code>lists</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>methods</code></strong> :&ensp;<code>List</code> of <code>methods</code> / <code>impacts</code> <code>to</code> <code>consider</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>You</code> <code>should</code> <code>provide</code> <code>named</code> <code>values</code> of <code>all</code> <code>the</code> <code>parameters</code> <code>declared</code> <code>in</code> <code>the</code> <code>model.</code>
<code>Values</code> <code>can</code> <code>be</code> <code>single</code> <code>value</code> or <code>list</code> of <code>samples</code>, <code>all</code> of <code>the</code> <code>same</code> <code>size</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiLCAAlgebric(models, methods, **params):
    &#34;&#34;&#34;Compute LCA by expressing the foreground model as symbolic expression of background activities and parameters.
    Then, compute &#39;static&#39; inventory of the referenced background activities.
    This enables a very fast recomputation of LCA with different parameters, useful for stochastic evaluation of parametrized model

    Parameters
    ----------
    models : Single model or list of models or dict of model:amount : if list of models, you cannot use param lists
    methods : List of methods / impacts to consider
    params : You should provide named values of all the parameters declared in the model. \
             Values can be single value or list of samples, all of the same size
    &#34;&#34;&#34;
    dfs = dict()

    if not isinstance(models, list):
        models = [models]

    for model in models:

        alpha = 1
        if type(model) is tuple :
            model, alpha=model

        lambdas = preMultiLCAAlgebric(model, methods, params.keys())

        df = postMultiLCAAlgebric(methods, lambdas, alpha=alpha, **params)

        model_name = _actName(model)

        # Single params ? =&gt; give the single row the name of the model activity
        if df.shape[0] == 1:
            df = df.rename(index={0: model_name})

        dfs[model_name] = df

    if len(dfs) == 1:
        df = list(dfs.values())[0]
        return df
    else:
        # Concat several dataframes for several models
        return pd.concat(list(dfs.values()))</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newActivity"><code class="name flex">
<span>def <span class="ident">newActivity</span></span>(<span>db_name, name, unit, exchanges={}, code=None, **argv)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new activity</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Name</code> <code>ofthe</code> <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>db_name</code></strong> :&ensp;<code>Destination</code> <code>DB</code> : <code>ACV</code> <code>DB</code> <code>by</code> default</dt>
<dd>&nbsp;</dd>
<dt><strong><code>exchanges</code></strong> :&ensp;<code>Dict</code> of <code>activity</code> =&gt; <code>amount.</code> <code>If</code> <code>amount</code> <code>is</code> <code>a</code> <code>string</code>, <code>is</code> <code>it</code> <code>considered</code> <code>as</code> <code>a</code> <code>formula</code> <code>with</code> <code>parameters</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>argv</code></strong> :&ensp;<code>extra</code> <code>params</code> <code>passed</code> <code>as</code> <code>properties</code> of <code>the</code> <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newActivity(db_name, name, unit,
        exchanges: Dict[Activity, Union[float, str]] = dict(),
        code=None,
        **argv):
    &#34;&#34;&#34;Creates a new activity

    Parameters
    ----------
    name : Name ofthe new activity
    db_name : Destination DB : ACV DB by default
    exchanges : Dict of activity =&gt; amount. If amount is a string, is it considered as a formula with parameters
    argv : extra params passed as properties of the new activity
    &#34;&#34;&#34;
    act = _newAct(db_name, code if code else name)
    act[&#39;name&#39;] = name
    act[&#39;type&#39;] = &#39;process&#39;
    act[&#39;unit&#39;] = unit
    act.update(argv)

    # Add exchanges
    act.addExchanges(exchanges)

    return act</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newBoolParam"><code class="name flex">
<span>def <span class="ident">newBoolParam</span></span>(<span>name, default, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newBoolParam(name, default, **kwargs):
    return newParamDef(name, ParamType.BOOL, default=default, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newEnumParam"><code class="name flex">
<span>def <span class="ident">newEnumParam</span></span>(<span>name, default, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newEnumParam(name, default, **kwargs):
    return newParamDef(name, ParamType.ENUM, default=default, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newFloatParam"><code class="name flex">
<span>def <span class="ident">newFloatParam</span></span>(<span>name, default, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newFloatParam(name, default, **kwargs):
    return newParamDef(name, ParamType.FLOAT, default=default, **kwargs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newInterpolatedAct"><code class="name flex">
<span>def <span class="ident">newInterpolatedAct</span></span>(<span>dbname, name, act1, act2, x1, x2, x, alpha1=1, alpha2=1, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a new activity made of interpolation of two similar activities.
For each exchange :
amount = alpha1 * a1 + (x - X1) * (alpha2 * a2 - alpha1 * a1) / (x2 - x1)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>Name</code> of <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>act1</code></strong> :&ensp;<code>Activity</code> <code>1</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>act2</code></strong> :&ensp;<code>Activity</code> <code>2</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>X</code> <code>for</code> <code>act1</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>X</code> <code>for</code> <code>act</code> <code>2</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>Should</code> <code>be</code> <code>a</code> <code>parameter</code> <code>symbol</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha1</code></strong> :&ensp;<code>Ratio</code> <code>for</code> <code>act1</code> (<code>Default</code> <code>value</code> = <code>1</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>alpha2</code></strong> :&ensp;<code>Ratio</code> <code>for</code> <code>act2</code> (<code>Default</code> <code>value</code> = <code>1</code>)</dt>
<dd>&nbsp;</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>Any</code> <code>other</code> <code>param</code> <code>will</code> <code>be</code> <code>added</code> <code>as</code> <code>attributes</code> of <code>new</code> <code>activity</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newInterpolatedAct(dbname: str, name: str, act1: ActivityExtended, act2: ActivityExtended, x1, x2, x, alpha1=1, alpha2=1, **kwargs):

    &#34;&#34;&#34;Creates a new activity made of interpolation of two similar activities.
    For each exchange :
    amount = alpha1 * a1 + (x - X1) * (alpha2 * a2 - alpha1 * a1) / (x2 - x1)

    Parameters
    ----------
    name : Name of new activity
    act1 : Activity 1
    act2 : Activity 2
    x1 : X for act1
    x2 : X for act 2
    x : Should be a parameter symbol
    alpha1 : Ratio for act1 (Default value = 1)
    alpha2 : Ratio for act2 (Default value = 1)
    kwargs : Any other param will be added as attributes of new activity
    &#34;&#34;&#34;
    res = copyActivity(dbname, act1, name, withExchanges=False, **kwargs)

    exch1_by_input = dict({exch[&#39;input&#39;]: exch for exch in act1.exchangesNp()})
    exch2_by_input = dict({exch[&#39;input&#39;]: exch for exch in act2.exchangesNp()})

    inputs = set(chain(exch1_by_input.keys(), exch2_by_input.keys()))

    for input in inputs:

        exch1 = exch1_by_input.get(input)
        exch2 = exch2_by_input.get(input)
        exch = exch1 if exch1 else exch2

        amount1 = exch1[&#39;amount&#39;] if exch1 else 0
        amount2 = exch2[&#39;amount&#39;] if exch2 else 0

        if exch1 and exch2 and exch1[&#39;name&#39;] != exch2[&#39;name&#39;]:
            raise Exception(&#34;Input %s refer two different names : %s, %s&#34; % (input, exch1[&#39;name&#39;], exch2[&#39;name&#39;]))

        amount = interpolate(x, x1, x2, amount1 * alpha1, amount2 * alpha2)
        act = getActByCode(*input)
        res.addExchanges({act: dict(amount=amount, name=exch[&#39;name&#39;])})
    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newParamDef"><code class="name flex">
<span>def <span class="ident">newParamDef</span></span>(<span>name, type, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Creates a param and register it into a global registry and as a brightway parameter</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newParamDef(name, type, **kwargs):
    &#34;&#34;&#34;Creates a param and register it into a global registry and as a brightway parameter&#34;&#34;&#34;
    if type == ParamType.ENUM:
        param = EnumParam(name, **kwargs)
    elif type == ParamType.BOOL :
        param = BooleanDef(name, **kwargs)
    else:
        param = ParamDef(name, type=type, **kwargs)

    # Put it in local registry (in memory)
    if name in _param_registry():
        _eprint(&#34;Param %s was already defined : overriding&#34; % name)
    _param_registry()[name] = param

    # Save in brightway2 project
    bwParams = [dict(name=key, amount=value) for key, value in param.expandParams().items()]
    bw.parameters.new_project_parameters(bwParams)

    return param</code></pre>
</details>
</dd>
<dt id="lca_algebraic.newSwitchAct"><code class="name flex">
<span>def <span class="ident">newSwitchAct</span></span>(<span>dbname, name, paramDef, acts_dict)</span>
</code></dt>
<dd>
<section class="desc"><p>Create a new parametrized, virtual activity, made of a map of other activities, controlled by an enum parameter.
This enables to implement a "Switch" with brightway parameters
Internally, this will create a linear sum of other activities controlled by <param_name>_<enum_value> : 0 or 1</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>paramDef</code></strong> :&ensp;<code>parameter</code> <code>definition</code> of <code>type</code> <code>enum</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>acts_dict</code></strong> :&ensp;<code>dict</code> of &lt;<code>enumValue</code>&gt; =&gt; <code>activity</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def newSwitchAct(dbname, name, paramDef: ParamDef, acts_dict: Dict[str, Activity]):
    &#34;&#34;&#34;Create a new parametrized, virtual activity, made of a map of other activities, controlled by an enum parameter.
    This enables to implement a &#34;Switch&#34; with brightway parameters
    Internally, this will create a linear sum of other activities controlled by &lt;param_name&gt;_&lt;enum_value&gt; : 0 or 1

    Parameters
    ----------
    paramDef : parameter definition of type enum
    acts_dict : dict of &lt;enumValue&gt; =&gt; activity
    &#34;&#34;&#34;

    # Transform map of enum values to correspoding formulas &lt;param_name&gt;_&lt;enum_value&gt;
    exch = {act: paramDef.symbol(key) for key, act in acts_dict.items()}
    res = newActivity(
        dbname,
        name,
        unit=list(acts_dict.values())[0][&#39;unit&#39;],
        exchanges=exch)


    # Unit of switch activity is the one of the children
    for key, act in acts_dict.items():
        if &#39;unit&#39; in act:
            res[&#39;unit&#39;] = act[&#39;unit&#39;]
            res.save()
    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.oat_dasboard"><code class="name flex">
<span>def <span class="ident">oat_dasboard</span></span>(<span>modelOrLambdas, impacts, param, n=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Analyse the evolution of impacts for a single parameter. The other parameters are set to their default values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>model</code></strong> :&ensp;<code>activity</code>, or <code>lambdas</code> <code>as</code> <code>precomputed</code> <code>by</code> <a title="lca_algebraic.preMultiLCAAlgebric" href="#lca_algebraic.preMultiLCAAlgebric"><code>preMultiLCAAlgebric()</code></a>, <code>for</code> <code>faster</code> <code>computation</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>impacts</code></strong> :&ensp;<code>set</code> of <code>methods</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>param</code></strong> :&ensp;<code>parameter</code> <code>to</code> <code>analyse</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>number</code> of <code>samples</code> of <code>the</code> <code>parameter</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oat_dasboard(modelOrLambdas, impacts, param: ParamDef, n=10) :
    &#39;&#39;&#39;
    Analyse the evolution of impacts for a single parameter. The other parameters are set to their default values.

    Parameters
    ----------
    model : activity, or lambdas as precomputed by preMultiLCAAlgebric, for faster computation
    impacts : set of methods
    param: parameter to analyse
    n: number of samples of the parameter
    &#39;&#39;&#39;

    params = {param.name : param.default for param in _param_registry().values()}

    # Compute range of values for given param
    params[param.name] = param.range(n)


    #print(&#34;Params: &#34;, params)

    if isinstance(modelOrLambdas, Activity) :
        df = multiLCAAlgebric(modelOrLambdas, impacts, **params)
    else :
        df = postMultiLCAAlgebric(impacts, modelOrLambdas, **params)

    # Add X values in the table
    pname = param.name
    if param.unit :
        pname = &#39;%s [%s]&#39; % (pname, param.unit)
    df.insert(0, pname, param.range(n))
    df = df.set_index(pname)


    def table() :
        display(df)

    def graph() :

        with warnings.catch_warnings():

            warnings.simplefilter(&#34;ignore&#34;)

            nb_rows = len(impacts) // 3 + 1

            fig, axes = plt.subplots(figsize=(15, 15))

            axes = df.plot(
                ax=axes, sharex=True, subplots=True,
                layout=(nb_rows, 3),
                #legend=None,
                kind = &#39;line&#39; if param.type == ParamType.FLOAT else &#39;bar&#39;)

            axes = axes.flatten()

            for ax, impact in zip(axes, impacts) :
                ax.set_ylim(ymin=0)
                ax.set_ylabel(_method_unit(impact))

            plt.show(fig)

    def change() :

        ch = (df.max() - df.min()) / df.median() * 100
        fig, ax = plt.subplots(figsize=(9, 6))
        plt.title(&#39;Relative change for %s&#39; % df.index.name)
        ch.plot(kind=&#39;barh&#39;, rot=30)
        ax.set_xlabel(&#39;Relative change of the median value (%)&#39;)
        plt.tight_layout()
        plt.show(fig)

    _display_tabs([
        (&#34;Graphs&#34;, graph),
        (&#34;Data&#34;, table),
        (&#34;Variation&#34;, change)
    ])</code></pre>
</details>
</dd>
<dt id="lca_algebraic.oat_dashboard_interact"><code class="name flex">
<span>def <span class="ident">oat_dashboard_interact</span></span>(<span>model, methods)</span>
</code></dt>
<dd>
<section class="desc"><p>Interative dashboard, with a dropdown for selecting parameter</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oat_dashboard_interact(model, methods):
    &#39;&#39;&#39;Interative dashboard, with a dropdown for selecting parameter&#39;&#39;&#39;

    lambdas = preMultiLCAAlgebric(model, methods, _param_registry().keys())

    def process_func(param) :
        oat_dasboard(lambdas, methods, _param_registry()[param])

    paramlist = list(_variable_params().keys())
    interact(process_func, param=paramlist)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.oat_matrix"><code class="name flex">
<span>def <span class="ident">oat_matrix</span></span>(<span>model, impacts, n=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a heatmap of the incertitude of the model, varying input parameters one a a time.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def oat_matrix(model, impacts, n=10) :
    &#39;&#39;&#39;Generates a heatmap of the incertitude of the model, varying input parameters one a a time.&#39;&#39;&#39;

    # Compile model into lambda functions for fast LCA
    lambdas = preMultiLCAAlgebric(model, impacts, _param_registry().keys())

    change = np.zeros((len(_variable_params()), len(impacts)))

    for iparam, param in enumerate(_variable_params().values()) :
        params = {param.name: param.default for param in _param_registry().values()}

        # Compute range of values for given param
        params[param.name] = param.range(n)

        # Compute LCA
        df = postMultiLCAAlgebric(impacts, lambdas, **params)

        # Compute change
        change[iparam] =  (df.max() - df.min()) / df.median() * 100

    # Build final heatmap
    change = pd.DataFrame(change, index=_variable_params().keys(), columns=[imp[2] for imp in impacts])
    _heatmap(change.transpose(), &#39;Change of impacts per variability of the input parameters (%)&#39;, 100, ints=True)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.postMultiLCAAlgebric"><code class="name flex">
<span>def <span class="ident">postMultiLCAAlgebric</span></span>(<span>methods, lambdas, alpha=1, **params)</span>
</code></dt>
<dd>
<section class="desc"><p>Compute LCA for a given set of parameters and pre-compiled lambda functions.
This function is used by <strong>multiLCAAlgebric</strong></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>methodAndLambdas</code></strong> :&ensp;<code>Output</code> of <a title="lca_algebraic.preMultiLCAAlgebric" href="#lca_algebraic.preMultiLCAAlgebric"><code>preMultiLCAAlgebric()</code></a></dt>
<dd>&nbsp;</dd>
<dt><strong><code>**params</code></strong> :&ensp;<code>Parameters</code> of <code>the</code> <code>model</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postMultiLCAAlgebric(methods, lambdas, alpha=1, **params):
    &#39;&#39;&#39;
        Compute LCA for a given set of parameters and pre-compiled lambda functions.
        This function is used by **multiLCAAlgebric**

        Parameters
        ----------
        methodAndLambdas : Output of preMultiLCAAlgebric
        **params : Parameters of the model
    &#39;&#39;&#39;

    # Check and expand params
    params = _completeParamValues(params)

    # Expand parameters as list of parameters
    param_length = 1

    for key, val in params.items():
        if isinstance(val, list):
            if param_length == 1:
                param_length = len(val)
            elif param_length != len(val):
                raise Exception(&#34;Parameters should be a single value or a list of same number of values&#34;)

    # Expand params and transform lists to np.array for vector computation
    for key in params.keys():
        val = params[key]
        if not isinstance(val, list):
            val = list([val] * param_length)
        params[key] = np.array(val)


    res = np.zeros((len(methods), param_length))

    # Compute result on whole vectors of parameter samples at a time : lambdas use numpy for vector computation
    for imethod, lambd in enumerate(lambdas):
        res[imethod, :] = alpha * lambd(**params)

    return pd.DataFrame(res, index=[method_name(method) for method in methods]).transpose()</code></pre>
</details>
</dd>
<dt id="lca_algebraic.preMultiLCAAlgebric"><code class="name flex">
<span>def <span class="ident">preMultiLCAAlgebric</span></span>(<span>model, methods, param_names=None, amount=1)</span>
</code></dt>
<dd>
<section class="desc"><p>This method transforms an activity into a set of functions ready to compute LCA very fast on a set on methods.
You may use is and pass the result to postMultiLCAAlgebric for fast computation on a model that does not change.</p>
<p>This method is used by multiLCAAlgebric</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def preMultiLCAAlgebric(model:ActivityExtended, methods, param_names=None, amount=1) :
    &#39;&#39;&#39;
        This method transforms an activity into a set of functions ready to compute LCA very fast on a set on methods.
        You may use is and pass the result to postMultiLCAAlgebric for fast computation on a model that does not change.

        This method is used by multiLCAAlgebric
    &#39;&#39;&#39;

    # print(&#34;computing model to expression for %s&#34; % model)
    expr, actBySymbolName = actToExpression(model)

    dbname = model.key[0]

    param_names = _expand_param_names(param_names)

    # Check missing params
    free_names = set([str(symb) for symb in expr.free_symbols])
    act_names = set([str(symb) for symb in actBySymbolName.keys()])
    expected_names  = free_names - act_names
    missing_names = expected_names - set(param_names)

    if len(missing_names) &gt; 0 :
        raise Exception(&#39;Missing parameter of the model : %s&#39; % str(missing_names))

    debug(param_names)

    for name in param_names :
        registry_names = _expand_param_names(_param_registry())
        if name not in registry_names :
            raise Exception(&#39;Model refers to unknown param &#34;%s&#34;&#39; % name)

    # Create dummy reference to biosphere
    # We cannot run LCA to biosphere activities
    # We create a technosphere activity mapping exactly to 1 biosphere item
    pureTechActBySymbol = OrderedDict()
    for name, act in actBySymbolName.items():
        if act[0] == BIOSPHERE3_DB_NAME:
            act = _getOrCreateDummyBiosphereActCopy(dbname, act[1])
        else:
            act = getActByCode(*act)
        pureTechActBySymbol[name] = act

    # List of activities, ordered
    acts = pureTechActBySymbol.values()

    # Transform to [{act1:1], {act2:1}, etc] for MultiLCA
    actsWithAmount = [{act: 1} for act in acts]

    # Compute LCA for all background activities and methods
    lca = _multiLCA(actsWithAmount, methods)

    # For each method, compute an algebric expression with activities replaced by their values
    lambdas = []
    for imethod, method in enumerate(methods):
        # print(&#34;Generating lamba function for %s / %s&#34; % (model, method))

        # Replace activities by their value in expression for this method
        sub = dict({symbol: lca.iloc[imethod, iact] for iact, symbol in enumerate(pureTechActBySymbol.keys())})
        method_expr = expr.xreplace(sub)

        # Tranform Sympy expression to lambda function, based on numpy to fast vectorial evaluation
        lambd = lambdify(param_names, method_expr, &#39;numpy&#39;)
        lambdas.append(lambd)

    return lambdas</code></pre>
</details>
</dd>
<dt id="lca_algebraic.printAct"><code class="name flex">
<span>def <span class="ident">printAct</span></span>(<span>*activities, **params)</span>
</code></dt>
<dd>
<section class="desc"><p>Print activities and their exchanges.
If parameter values are provided, formulas will be evaluated accordingly</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printAct(*activities,  **params):
    &#34;&#34;&#34;
    Print activities and their exchanges.
    If parameter values are provided, formulas will be evaluated accordingly
    &#34;&#34;&#34;
    tables = []
    names = []

    for act in activities:
        df = pd.DataFrame(index=[&#39;input&#39;, &#39;amount&#39;, &#39;unit&#39;, &#39;type&#39;])
        data = dict()
        for (i, exc) in enumerate(act.exchanges()):
            input = bw.get_activity(exc.input.key)
            amount = _getAmountOrFormula(exc)

            # Params provided ? Evaluate formulas
            if len(params) &gt; 0 and isinstance(amount, Basic):
                new_params = [(name, value) for name, value in _completeParamValues(params).items()]
                amount = amount.subs(new_params)

            name = exc[&#39;name&#39;]
            if &#39;location&#39; in input and input[&#39;location&#39;] != &#34;GLO&#34;:
                name += &#34;#%s&#34; % input[&#39;location&#39;]
            if exc.input.key[0] not in [BIOSPHERE3_DB_NAME, ECOINVENT_DB_NAME] :
                name += &#34; {user-db}&#34;

            iname = name
            i=1
            while iname in data :
                iname = &#34;%s#%d&#34; % (name, i)
                i += 1

            data[iname] = [str(input), amount, exc.unit, exc[&#39;type&#39;]]

        for key, values in data.items() :
            df[key] = values

        tables.append(df.T)
        names.append(_actDesc(act))

    full = pd.concat(tables, axis=1, keys=names, sort=True)

    if len(activities) == 2 :
        yellow = &#34;background-color:yellow&#34;
        iamount1 = full.columns.get_loc((names[0], &#34;amount&#34;))
        iamount2 = full.columns.get_loc((names[1], &#34;amount&#34;))
        iact1 = full.columns.get_loc((names[0], &#34;input&#34;))
        iact2 = full.columns.get_loc((names[1], &#34;input&#34;))
        def same_amount(row) :
            res = [&#34;&#34;] * len(row)

            if row[iamount1] != row[iamount2] :
                res[iamount1] = yellow
                res[iamount2] = yellow
            if row[iact1] != row[iact2]:
                res[iact1] = yellow
                res[iact2] = yellow
            return res

        full = full.style.apply(same_amount, axis=1)

    display(full)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.resetDb"><code class="name flex">
<span>def <span class="ident">resetDb</span></span>(<span>db_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Create or cleanup a user DB</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetDb(db_name):
    &#34;&#34;&#34; Create or cleanup a user DB&#34;&#34;&#34;
    if db_name in bw.databases:
        _eprint(&#34;Db %s was here. Reseting it&#34; % db_name)
        del bw.databases[db_name]
    db = bw.Database(db_name)
    db.write(dict())</code></pre>
</details>
</dd>
<dt id="lca_algebraic.resetParams"><code class="name flex">
<span>def <span class="ident">resetParams</span></span>(<span>db_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Reset project and activity parameters</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resetParams(db_name):
    &#34;&#34;&#34;Reset project and activity parameters&#34;&#34;&#34;
    _param_registry().clear()
    ProjectParameter.delete().execute()
    ActivityParameter.delete().execute()
    DatabaseParameter.delete().execute()
    Group.delete().execute()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="lca_algebraic.ActivityExtended"><code class="flex name class">
<span>class <span class="ident">ActivityExtended</span></span>
<span>(</span><span>document=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Improved API for activity : adding a few useful methods.
Those methods are backported to #Activity in order to be directly available on all existing instances</p>
<p>Create an <code>Activity</code> proxy object.</p>
<p>If this is a new activity, can pass <code>kwargs</code>.</p>
<p>If the activity exists in the database, <code>document</code> should be an <code>ActivityDataset</code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActivityExtended(Activity):
    &#34;&#34;&#34;Improved API for activity : adding a few useful methods.
    Those methods are backported to #Activity in order to be directly available on all existing instances
    &#34;&#34;&#34;

    def getExchange(self, name=None, input=None, single=True):
        &#34;&#34;&#34;Get exchange by name or input

        Parameters
        ----------
        name : name of the exchange. Name can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffised by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

        single :True if a single match is expected. Otherwize, a list of result is returned

        Returns
        -------
            Single exchange or list of exchanges (if _single is False or &#34;name&#34; contains a &#39;*&#39;)
            raise Exception if not matching exchange found
        &#34;&#34;&#34;

        def single_match(name, exch) :

            # Name can be &#34;Elecricity#RER&#34;
            if &#34;#&#34; in name:
                name, loc = name.split(&#34;#&#34;)
                negative = False
                if loc.startswith(&#34;!&#34;) :
                    negative = True
                    loc = loc[1:]
                act = getActByCode(*exch[&#39;input&#39;])

                if not &#39;location&#39; in act or (negative and act[&#39;location&#39;] == loc) or (not negative and act[&#39;location&#39;] != loc) :
                    return False

            if &#39;*&#39; in name :
                name = name.replace(&#39;*&#39;, &#39;&#39;)
                return name in exch[&#39;name&#39;]
            else :
                return name == exch[&#39;name&#39;]


        def match(exch):
            if name :
                if isinstance(name, list):
                    return any(single_match(iname, exch) for iname in name)
                else:
                    return single_match(name, exch)

            if input:
                return input == exch[&#39;input&#39;]

        exchs = list(exch for exch in self.exchangesNp() if match(exch))
        if len(exchs) == 0:
            raise Exception(&#34;Found no exchange matching name : %s&#34; % name)

        if single and len(exchs) != 1:
            raise Exception(&#34;Expected 1 exchange with name &#39;%s&#39; found %d&#34; % (name, len(exchs)))
        if single:
            return exchs[0]
        else:
            return exchs

    def setOutputAmount(self, amount):
        &#39;&#39;&#39;Set the amount for the single output exchange (1 by default)&#39;&#39;&#39;
        self.addExchanges({self : amount})

    def updateExchanges(self, updates: Dict[str, any] = dict()):
        &#34;&#34;&#34;Update existing exchanges, by name.

        Parameters
        ----------
        updates : Dict of &#34;&lt;exchange name&gt;&#34; =&gt; &lt;new value&gt;

            &lt;exchange name&gt; can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
            It can also be suffixed by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
            Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

            &lt;New Value&gt;  : either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
            or dict of attributes, for updating both at once, or any other attribute.
            The amount can reference the symbol &#39;old_amount&#39; that will be replaced with the current amount of the exchange.
        &#34;&#34;&#34;

        # Update exchanges
        for name, attrs in updates.items():

            exchs = self.getExchange(name, single=not &#39;*&#39; in name)
            if not isinstance(exchs, list):
                exchs = [exchs]
            for exch in exchs:

                if attrs is None:
                    exch.delete()
                    exch.save()
                    continue

                # Single value ? =&gt; amount
                if not isinstance(attrs, dict):
                    if isinstance(attrs, Activity):
                        attrs = dict(input=attrs)
                    else :
                        attrs = dict(amount=attrs)

                if &#39;amount&#39; in attrs:
                    attrs.update(_amountToFormula(attrs[&#39;amount&#39;], exch[&#39;amount&#39;]))

                exch.update(attrs)
                exch.save()

                # We have a formula now ? =&gt; register it to parametrized exchange
                if &#39;formula&#39; in attrs:
                    bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def deleteExchanges(self, name, single=True):
        &#39;&#39;&#39; Remove matching exchanges &#39;&#39;&#39;
        exchs = self.getExchange(name, single=single)
        if not isinstance(exchs, list):
            exchs = [exchs]
        if len(exchs) == 0 :
            raise Exception(&#34;No exchange found for &#39;%s&#39;&#34; % name)
        for ex in exchs :
            ex.delete()
            ex.save()
        self.save()

    def substituteWithDefault(self, exchange_name: str, switch_act: Activity, paramSwitch: EnumParam, amount=None):

        &#34;&#34;&#34;Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
        For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by &#39;&lt;param_name&gt;_default&#39;,
        making it null as soon as one enum value is set.

        This is useful for changing electricty mix, leaving the default one if needed

        Parameters
        ----------
        act : Activity to update
        exchange_name : Name of the exchange to update
        switch_act : Activity to substitue as input
        amount : Amount of the input (uses previous amount by default)
        &#34;&#34;&#34;

        current_exch = self.getExchange(exchange_name)

        prev_amount = amount if amount else _getAmountOrFormula(current_exch)

        self.addExchanges({switch_act: prev_amount})
        self.updateExchanges({exchange_name: paramSwitch.symbol(None) * prev_amount})

    def addExchanges(self, exchanges: Dict[Activity, Union[NumOrExpression, dict]] = dict()):
        &#34;&#34;&#34;Add exchanges to an existing activity, with a compact syntax :

        Parameters
        ----------
        exchanges : Dict of activity =&gt; amount or activity =&gt; attributes_dict. \
            Amount being either a fixed value or Sympy expression (arithmetic expression of Sympy symbols)
        &#34;&#34;&#34;
        parametrized = False
        for sub_act, attrs in exchanges.items():

            if isinstance(attrs, dict):
                amount = attrs.pop(&#39;amount&#39;)
            else:
                amount = attrs
                attrs = dict()

            exch = self.new_exchange(
                input=sub_act.key,
                name=sub_act[&#39;name&#39;],
                unit=sub_act[&#39;unit&#39;] if &#39;unit&#39; in sub_act else None,
                type=&#39;production&#39; if self == sub_act else &#39;biosphere&#39; if sub_act[&#39;database&#39;] == BIOSPHERE3_DB_NAME else &#39;technosphere&#39;)

            exch.update(attrs)
            exch.update(_amountToFormula(amount))
            if &#39;formula&#39; in exch:
                parametrized = True

            exch.save()
        self.save()
        if parametrized:
            bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)

    def getAmount(self, *args, sum=False, **kargs):
        &#34;&#34;&#34;
        Get the amount of one or several exchanges, selected by name or input. See #getExchange()
        &#34;&#34;&#34;
        exchs = self.getExchange(*args, single=not sum, **kargs)
        if sum:
            res = 0
            if len(exchs) == 0:
                raise Exception(&#34;No exchange found&#34;)
            for exch in exchs:
                res += _getAmountOrFormula(exch)
            return res
        else:
            return _getAmountOrFormula(exchs)

    def exchangesNp(self):
        &#34;&#34;&#34; List of exchange, except production (output) one.&#34;&#34;&#34;
        for exch in self.exchanges():
            if exch[&#39;input&#39;] != exch[&#39;output&#39;]:
                yield exch</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>bw2data.backends.peewee.proxies.Activity</li>
<li>bw2data.proxies.ActivityProxyBase</li>
<li>bw2data.proxies.ProxyBase</li>
<li>collections.abc.MutableMapping</li>
<li>collections.abc.Mapping</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lca_algebraic.ActivityExtended.addExchanges"><code class="name flex">
<span>def <span class="ident">addExchanges</span></span>(<span>self, exchanges={})</span>
</code></dt>
<dd>
<section class="desc"><p>Add exchanges to an existing activity, with a compact syntax :</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>exchanges</code></strong> :&ensp;<code>Dict</code> of <code>activity</code> =&gt; <code>amount</code> or <code>activity</code> =&gt; <code>attributes_dict.</code>
<code>Amount</code> <code>being</code> <code>either</code> <code>a</code> <code>fixed</code> <code>value</code> or <code>Sympy</code> <code>expression</code> (<code>arithmetic</code> <code>expression</code> of <code>Sympy</code> <code>symbols</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addExchanges(self, exchanges: Dict[Activity, Union[NumOrExpression, dict]] = dict()):
    &#34;&#34;&#34;Add exchanges to an existing activity, with a compact syntax :

    Parameters
    ----------
    exchanges : Dict of activity =&gt; amount or activity =&gt; attributes_dict. \
        Amount being either a fixed value or Sympy expression (arithmetic expression of Sympy symbols)
    &#34;&#34;&#34;
    parametrized = False
    for sub_act, attrs in exchanges.items():

        if isinstance(attrs, dict):
            amount = attrs.pop(&#39;amount&#39;)
        else:
            amount = attrs
            attrs = dict()

        exch = self.new_exchange(
            input=sub_act.key,
            name=sub_act[&#39;name&#39;],
            unit=sub_act[&#39;unit&#39;] if &#39;unit&#39; in sub_act else None,
            type=&#39;production&#39; if self == sub_act else &#39;biosphere&#39; if sub_act[&#39;database&#39;] == BIOSPHERE3_DB_NAME else &#39;technosphere&#39;)

        exch.update(attrs)
        exch.update(_amountToFormula(amount))
        if &#39;formula&#39; in exch:
            parametrized = True

        exch.save()
    self.save()
    if parametrized:
        bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.deleteExchanges"><code class="name flex">
<span>def <span class="ident">deleteExchanges</span></span>(<span>self, name, single=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Remove matching exchanges</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteExchanges(self, name, single=True):
    &#39;&#39;&#39; Remove matching exchanges &#39;&#39;&#39;
    exchs = self.getExchange(name, single=single)
    if not isinstance(exchs, list):
        exchs = [exchs]
    if len(exchs) == 0 :
        raise Exception(&#34;No exchange found for &#39;%s&#39;&#34; % name)
    for ex in exchs :
        ex.delete()
        ex.save()
    self.save()</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.exchangesNp"><code class="name flex">
<span>def <span class="ident">exchangesNp</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>List of exchange, except production (output) one.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exchangesNp(self):
    &#34;&#34;&#34; List of exchange, except production (output) one.&#34;&#34;&#34;
    for exch in self.exchanges():
        if exch[&#39;input&#39;] != exch[&#39;output&#39;]:
            yield exch</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.getAmount"><code class="name flex">
<span>def <span class="ident">getAmount</span></span>(<span>self, *args, sum=False, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the amount of one or several exchanges, selected by name or input. See #getExchange()</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getAmount(self, *args, sum=False, **kargs):
    &#34;&#34;&#34;
    Get the amount of one or several exchanges, selected by name or input. See #getExchange()
    &#34;&#34;&#34;
    exchs = self.getExchange(*args, single=not sum, **kargs)
    if sum:
        res = 0
        if len(exchs) == 0:
            raise Exception(&#34;No exchange found&#34;)
        for exch in exchs:
            res += _getAmountOrFormula(exch)
        return res
    else:
        return _getAmountOrFormula(exchs)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.getExchange"><code class="name flex">
<span>def <span class="ident">getExchange</span></span>(<span>self, name=None, input=None, single=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Get exchange by name or input</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>name</code> of <code>the</code> <code>exchange.</code> <code>Name</code> <code>can</code> <code>be</code> <code>suffixed</code> <code>with</code> <code>'</code>#<code>LOCATION'</code> <code>to</code> <code>distinguish</code> <code>several</code> <code>exchanges</code> <code>with</code> <code>same</code> <code>name.</code>
<code>It</code> <code>can</code> <code>also</code> <code>be</code> <code>suffised</code> <code>by</code> <code>'</code>*<code>'</code> <code>to</code> <code>match</code> <code>an</code> <code>exchange</code> <code>starting</code> <code>with</code> <code>this</code> <code>name.</code> <code>Location</code> <code>can</code> <code>be</code> <code>a</code> <code>negative</code> <code>match</code> <code>'</code>!<code>'</code></dt>
<dd>Exampple : "Wood*#!RoW" matches any exchange with name
containing Wood, and location not "RoW"</dd>
</dl>
<p>single :True if a single match is expected. Otherwize, a list of result is returned</p>
<h2 id="returns">Returns</h2>
<pre><code>Single exchange or list of exchanges (if _single is False or "name" contains a '*')
raise Exception if not matching exchange found
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getExchange(self, name=None, input=None, single=True):
    &#34;&#34;&#34;Get exchange by name or input

    Parameters
    ----------
    name : name of the exchange. Name can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
        It can also be suffised by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
        Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

    single :True if a single match is expected. Otherwize, a list of result is returned

    Returns
    -------
        Single exchange or list of exchanges (if _single is False or &#34;name&#34; contains a &#39;*&#39;)
        raise Exception if not matching exchange found
    &#34;&#34;&#34;

    def single_match(name, exch) :

        # Name can be &#34;Elecricity#RER&#34;
        if &#34;#&#34; in name:
            name, loc = name.split(&#34;#&#34;)
            negative = False
            if loc.startswith(&#34;!&#34;) :
                negative = True
                loc = loc[1:]
            act = getActByCode(*exch[&#39;input&#39;])

            if not &#39;location&#39; in act or (negative and act[&#39;location&#39;] == loc) or (not negative and act[&#39;location&#39;] != loc) :
                return False

        if &#39;*&#39; in name :
            name = name.replace(&#39;*&#39;, &#39;&#39;)
            return name in exch[&#39;name&#39;]
        else :
            return name == exch[&#39;name&#39;]


    def match(exch):
        if name :
            if isinstance(name, list):
                return any(single_match(iname, exch) for iname in name)
            else:
                return single_match(name, exch)

        if input:
            return input == exch[&#39;input&#39;]

    exchs = list(exch for exch in self.exchangesNp() if match(exch))
    if len(exchs) == 0:
        raise Exception(&#34;Found no exchange matching name : %s&#34; % name)

    if single and len(exchs) != 1:
        raise Exception(&#34;Expected 1 exchange with name &#39;%s&#39; found %d&#34; % (name, len(exchs)))
    if single:
        return exchs[0]
    else:
        return exchs</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.setOutputAmount"><code class="name flex">
<span>def <span class="ident">setOutputAmount</span></span>(<span>self, amount)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the amount for the single output exchange (1 by default)</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setOutputAmount(self, amount):
    &#39;&#39;&#39;Set the amount for the single output exchange (1 by default)&#39;&#39;&#39;
    self.addExchanges({self : amount})</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.substituteWithDefault"><code class="name flex">
<span>def <span class="ident">substituteWithDefault</span></span>(<span>self, exchange_name, switch_act, paramSwitch, amount=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by '<param_name>_default',
making it null as soon as one enum value is set.</p>
<p>This is useful for changing electricty mix, leaving the default one if needed</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>act</code></strong> :&ensp;<code>Activity</code> <code>to</code> <code>update</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>exchange_name</code></strong> :&ensp;<code>Name</code> of <code>the</code> <code>exchange</code> <code>to</code> <code>update</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>switch_act</code></strong> :&ensp;<code>Activity</code> <code>to</code> <code>substitue</code> <code>as</code> <code>input</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>Amount</code> of <code>the</code> <code>input</code> (<code>uses</code> <code>previous</code> <code>amount</code> <code>by</code> default)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def substituteWithDefault(self, exchange_name: str, switch_act: Activity, paramSwitch: EnumParam, amount=None):

    &#34;&#34;&#34;Substitutes one exchange with a switch on other activities, or fallback to the current one as default (parameter set to None)
    For this purpose, we create a new exchange referencing the activity switch, and we multiply current activity by &#39;&lt;param_name&gt;_default&#39;,
    making it null as soon as one enum value is set.

    This is useful for changing electricty mix, leaving the default one if needed

    Parameters
    ----------
    act : Activity to update
    exchange_name : Name of the exchange to update
    switch_act : Activity to substitue as input
    amount : Amount of the input (uses previous amount by default)
    &#34;&#34;&#34;

    current_exch = self.getExchange(exchange_name)

    prev_amount = amount if amount else _getAmountOrFormula(current_exch)

    self.addExchanges({switch_act: prev_amount})
    self.updateExchanges({exchange_name: paramSwitch.symbol(None) * prev_amount})</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ActivityExtended.updateExchanges"><code class="name flex">
<span>def <span class="ident">updateExchanges</span></span>(<span>self, updates={})</span>
</code></dt>
<dd>
<section class="desc"><p>Update existing exchanges, by name.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>updates</code></strong> :&ensp;<code>Dict</code> of <code>"</code>&lt;<code>exchange</code> <code>name</code>&gt;<code>"</code> =&gt; &lt;<code>new</code> <code>value</code>&gt;</dt>
<dd>
<p><exchange name> can be suffixed with '#LOCATION' to distinguish several exchanges with same name.
It can also be suffixed by '<em>' to match an exchange starting with this name. Location can be a negative match '!'
Exampple : "Wood</em>#!RoW" matches any exchange with name
containing Wood, and location not "RoW"</p>
<p><New Value>
: either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
or dict of attributes, for updating both at once, or any other attribute.
The amount can reference the symbol 'old_amount' that will be replaced with the current amount of the exchange.</p>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateExchanges(self, updates: Dict[str, any] = dict()):
    &#34;&#34;&#34;Update existing exchanges, by name.

    Parameters
    ----------
    updates : Dict of &#34;&lt;exchange name&gt;&#34; =&gt; &lt;new value&gt;

        &lt;exchange name&gt; can be suffixed with &#39;#LOCATION&#39; to distinguish several exchanges with same name. \
        It can also be suffixed by &#39;*&#39; to match an exchange starting with this name. Location can be a negative match &#39;!&#39;
        Exampple : &#34;Wood*#!RoW&#34; matches any exchange with name  containing Wood, and location not &#34;RoW&#34;

        &lt;New Value&gt;  : either single value (float or SympPy expression) for updating only amount, or activity for updating only input,
        or dict of attributes, for updating both at once, or any other attribute.
        The amount can reference the symbol &#39;old_amount&#39; that will be replaced with the current amount of the exchange.
    &#34;&#34;&#34;

    # Update exchanges
    for name, attrs in updates.items():

        exchs = self.getExchange(name, single=not &#39;*&#39; in name)
        if not isinstance(exchs, list):
            exchs = [exchs]
        for exch in exchs:

            if attrs is None:
                exch.delete()
                exch.save()
                continue

            # Single value ? =&gt; amount
            if not isinstance(attrs, dict):
                if isinstance(attrs, Activity):
                    attrs = dict(input=attrs)
                else :
                    attrs = dict(amount=attrs)

            if &#39;amount&#39; in attrs:
                attrs.update(_amountToFormula(attrs[&#39;amount&#39;], exch[&#39;amount&#39;]))

            exch.update(attrs)
            exch.save()

            # We have a formula now ? =&gt; register it to parametrized exchange
            if &#39;formula&#39; in attrs:
                bw.parameters.add_exchanges_to_group(DEFAULT_PARAM_GROUP, self)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lca_algebraic.BooleanDef"><code class="flex name class">
<span>class <span class="ident">BooleanDef</span></span>
<span>(</span><span>name, *karg, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Parameter with discrete value 0 or 1</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BooleanDef(ParamDef):
    &#34;&#34;&#34;Parameter with discrete value 0 or 1&#34;&#34;&#34;

    def __init__(self, name, **argv):
        super(BooleanDef, self).__init__(name, ParamType.BOOL, min=0, max=1, **argv)

    def range(self, n):
        return [0, 1]

    def rand(self, alpha):
        return round(alpha)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lca_algebraic.ParamDef" href="#lca_algebraic.ParamDef">ParamDef</a></li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lca_algebraic.ParamDef" href="#lca_algebraic.ParamDef">ParamDef</a></b></code>:
<ul class="hlist">
<li><code><a title="lca_algebraic.ParamDef.default_assumptions" href="#lca_algebraic.ParamDef.default_assumptions">default_assumptions</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.rand" href="#lca_algebraic.ParamDef.rand">rand</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.range" href="#lca_algebraic.ParamDef.range">range</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lca_algebraic.DistributionType"><code class="flex name class">
<span>class <span class="ident">DistributionType</span></span>
</code></dt>
<dd>
<section class="desc"><p>Type of distribution</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DistributionType :
    &#39;&#39;&#39;Type of distribution&#39;&#39;&#39;
    LINEAR = &#34;linear&#34;
    NORMAL = &#34;normal&#34;
    TRIANGLE = &#34;triangle&#34;
    FIXED = &#34;fixed&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.DistributionType.FIXED"><code class="name">var <span class="ident">FIXED</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.DistributionType.LINEAR"><code class="name">var <span class="ident">LINEAR</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.DistributionType.NORMAL"><code class="name">var <span class="ident">NORMAL</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.DistributionType.TRIANGLE"><code class="name">var <span class="ident">TRIANGLE</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
</dd>
<dt id="lca_algebraic.EnumParam"><code class="flex name class">
<span>class <span class="ident">EnumParam</span></span>
<span>(</span><span>name, *karg, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Enum param is a facility representing a choice / switch as many boolean parameters.
It is not itself a Sympy symbol. use #symbol("value") to access it</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnumParam(ParamDef):
    &#34;&#34;&#34;Enum param is a facility representing a choice / switch as many boolean parameters.
    It is not itself a Sympy symbol. use #symbol(&#34;value&#34;) to access it&#34;&#34;&#34;

    def __init__(self, name, values: List[str], **argv):
        super(EnumParam, self).__init__(name, ParamType.ENUM, min=None, max=None, **argv)
        self.values = values

    def expandParams(self, currValue=None):
        values = self.values + [None]
        res = dict()
        for enum_val in values:
            var_name = &#34;%s_%s&#34; % (self.name, enum_val if enum_val is not None else &#34;default&#34;)
            res[var_name] = 1.0 if enum_val == currValue else 0.0
        return res

    def symbol(self, enumValue):
        &#34;&#34;&#34;Access parameter for each enum value : &lt;paramName&gt;_&lt;paramValue&gt;&#34;&#34;&#34;
        if enumValue is None:
            return Symbol(self.name + &#39;_default&#39;)
        if not enumValue in self.values:
            raise Exception(&#34;enumValue should be one of %s. Was %s&#34; % (str(self.values), enumValue))
        return Symbol(self.name + &#39;_&#39; + enumValue)

    def names(self) :
        return [&#34;%s_%s&#34; % (self.name, value) for value in (self.values + [&#34;default&#34;]) ]

    def rand(self, alpha):
        i = math.ceil(alpha * (len(self.values))) -1
        return self.values[int(i)]

    def range(self, n):
        return self.values</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="lca_algebraic.ParamDef" href="#lca_algebraic.ParamDef">ParamDef</a></li>
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="lca_algebraic.EnumParam.expandParams"><code class="name flex">
<span>def <span class="ident">expandParams</span></span>(<span>self, currValue=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expandParams(self, currValue=None):
    values = self.values + [None]
    res = dict()
    for enum_val in values:
        var_name = &#34;%s_%s&#34; % (self.name, enum_val if enum_val is not None else &#34;default&#34;)
        res[var_name] = 1.0 if enum_val == currValue else 0.0
    return res</code></pre>
</details>
</dd>
<dt id="lca_algebraic.EnumParam.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self) :
    return [&#34;%s_%s&#34; % (self.name, value) for value in (self.values + [&#34;default&#34;]) ]</code></pre>
</details>
</dd>
<dt id="lca_algebraic.EnumParam.symbol"><code class="name flex">
<span>def <span class="ident">symbol</span></span>(<span>self, enumValue)</span>
</code></dt>
<dd>
<section class="desc"><p>Access parameter for each enum value : <paramName>_<paramValue></p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def symbol(self, enumValue):
    &#34;&#34;&#34;Access parameter for each enum value : &lt;paramName&gt;_&lt;paramValue&gt;&#34;&#34;&#34;
    if enumValue is None:
        return Symbol(self.name + &#39;_default&#39;)
    if not enumValue in self.values:
        raise Exception(&#34;enumValue should be one of %s. Was %s&#34; % (str(self.values), enumValue))
    return Symbol(self.name + &#39;_&#39; + enumValue)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="lca_algebraic.ParamDef" href="#lca_algebraic.ParamDef">ParamDef</a></b></code>:
<ul class="hlist">
<li><code><a title="lca_algebraic.ParamDef.default_assumptions" href="#lca_algebraic.ParamDef.default_assumptions">default_assumptions</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.rand" href="#lca_algebraic.ParamDef.rand">rand</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.range" href="#lca_algebraic.ParamDef.range">range</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="lca_algebraic.ParamDef"><code class="flex name class">
<span>class <span class="ident">ParamDef</span></span>
<span>(</span><span>name, *karg, **kargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generic definition of a parameter, with name, bound, type, distribution
This definition will serve both to generate brightway2 parameters and to evaluate.</p>
<p>This class inherits sympy Symbol, making it possible to use in standard arithmetic python
while keeping it as a symbolic expression (delayed evaluation).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamDef(Symbol):
    &#39;&#39;&#39;Generic definition of a parameter, with name, bound, type, distribution
    This definition will serve both to generate brightway2 parameters and to evaluate.

    This class inherits sympy Symbol, making it possible to use in standard arithmetic python
    while keeping it as a symbolic expression (delayed evaluation).
    &#39;&#39;&#39;

    def __new__(cls, name, *karg, **kargs):
        return Symbol.__new__(cls, name)

    def __init__(self, name, type: str, default, min=None, max=None, unit=&#34;&#34;, description=&#34;&#34;, label=None, label_fr=None, group=None, distrib=DistributionType.LINEAR, std=None):
        self.name = name
        self.type = type
        self.default = default
        self.description = description
        self.min = min
        self.max = max
        self.unit = unit
        self.label = label
        self.label_fr = label_fr
        self.group=group
        self.distrib = distrib

        if type == ParamType.FLOAT and self.min is None :
            self.distrib = DistributionType.FIXED

        if distrib == DistributionType.NORMAL and std is None :
            raise Exception(&#34;Standard deviation is mandatory for normal distribution&#34;)
        self.std = std

    def label(self):
        if self.label is not None :
            return self.label
        else :
            return self.name.replace(&#34;_&#34;, &#34; &#34;)

    def range(self, n) :
        &#39;&#39;&#39;Used for parametric analysis&#39;&#39;&#39;
        step = (self.max - self.min) / (n - 1)
        return list(i * step + self.min for i in range(0, n))


    def rand(self, alpha):
        &#34;&#34;&#34;Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter&#34;&#34;&#34;
        if self.distrib == DistributionType.LINEAR :
            return self.min + alpha * (self.max - self.min)

        elif self.distrib == DistributionType.TRIANGLE :
            if not hasattr(self, &#34;_distrib&#34;) :
                scale = self.max - self.min
                c = (self.default - self.min) / scale
                self._distrib = triang(c, loc=self.min, scale=scale)

            return self._distrib.ppf(alpha)

        elif self.distrib == DistributionType.NORMAL :
            if not hasattr(self, &#34;_distrib&#34;) :
                self._distrib = truncnorm(
                    (self.min - self.default) / self.std,
                    (self.max - self.min) / self.std,
                    loc=self.default,
                    scale=self.std)

            return self._distrib.ppf(alpha)

        else :
            raise Exception(&#34;Unknowk distribution type &#34; + self.distrib)



    # Expand parameter (useful for enum param)
    def expandParams(self, value=None) -&gt; Dict[str, float]:
        if value == None:
            value = self.default
        return {self.name: value}

    # Useful for enum param, having several names
    def names(self) :
        return [self.name]

    def __repr__(self):
        return self.name</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>sympy.core.symbol.Symbol</li>
<li>sympy.core.expr.AtomicExpr</li>
<li>sympy.core.basic.Atom</li>
<li>sympy.core.expr.Expr</li>
<li>sympy.logic.boolalg.Boolean</li>
<li>sympy.core.basic.Basic</li>
<li>sympy.core.evalf.EvalfMixin</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="lca_algebraic.BooleanDef" href="#lca_algebraic.BooleanDef">BooleanDef</a></li>
<li><a title="lca_algebraic.EnumParam" href="#lca_algebraic.EnumParam">EnumParam</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.ParamDef.default_assumptions"><code class="name">var <span class="ident">default_assumptions</span></code></dt>
<dd>
<section class="desc"><p>A FactKB specialised for the built-in rules</p>
<p>This is the only kind of FactKB that Basic objects should use.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="lca_algebraic.ParamDef.expandParams"><code class="name flex">
<span>def <span class="ident">expandParams</span></span>(<span>self, value=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expandParams(self, value=None) -&gt; Dict[str, float]:
    if value == None:
        value = self.default
    return {self.name: value}</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ParamDef.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def label(self):
    if self.label is not None :
        return self.label
    else :
        return self.name.replace(&#34;_&#34;, &#34; &#34;)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ParamDef.names"><code class="name flex">
<span>def <span class="ident">names</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def names(self) :
    return [self.name]</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ParamDef.rand"><code class="name flex">
<span>def <span class="ident">rand</span></span>(<span>self, alpha)</span>
</code></dt>
<dd>
<section class="desc"><p>Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rand(self, alpha):
    &#34;&#34;&#34;Transforms a random number between 0 and 1 to valid value according to the distribution of probability of the parameter&#34;&#34;&#34;
    if self.distrib == DistributionType.LINEAR :
        return self.min + alpha * (self.max - self.min)

    elif self.distrib == DistributionType.TRIANGLE :
        if not hasattr(self, &#34;_distrib&#34;) :
            scale = self.max - self.min
            c = (self.default - self.min) / scale
            self._distrib = triang(c, loc=self.min, scale=scale)

        return self._distrib.ppf(alpha)

    elif self.distrib == DistributionType.NORMAL :
        if not hasattr(self, &#34;_distrib&#34;) :
            self._distrib = truncnorm(
                (self.min - self.default) / self.std,
                (self.max - self.min) / self.std,
                loc=self.default,
                scale=self.std)

        return self._distrib.ppf(alpha)

    else :
        raise Exception(&#34;Unknowk distribution type &#34; + self.distrib)</code></pre>
</details>
</dd>
<dt id="lca_algebraic.ParamDef.range"><code class="name flex">
<span>def <span class="ident">range</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<section class="desc"><p>Used for parametric analysis</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def range(self, n) :
    &#39;&#39;&#39;Used for parametric analysis&#39;&#39;&#39;
    step = (self.max - self.min) / (n - 1)
    return list(i * step + self.min for i in range(0, n))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="lca_algebraic.ParamType"><code class="flex name class">
<span>class <span class="ident">ParamType</span></span>
</code></dt>
<dd>
<section class="desc"><p>Type of parameters</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParamType:
    &#39;&#39;&#39;Type of parameters&#39;&#39;&#39;
    ENUM = &#34;enum&#34;
    BOOL = &#34;bool&#34;
    FLOAT = &#34;float&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="lca_algebraic.ParamType.BOOL"><code class="name">var <span class="ident">BOOL</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.ParamType.ENUM"><code class="name">var <span class="ident">ENUM</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
<dt id="lca_algebraic.ParamType.FLOAT"><code class="name">var <span class="ident">FLOAT</span></code></dt>
<dd>
<section class="desc"><p>str(object='') -&gt; str
str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.<strong>str</strong>() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.</p></section>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="lca_algebraic.actToExpression" href="#lca_algebraic.actToExpression">actToExpression</a></code></li>
<li><code><a title="lca_algebraic.copyActivity" href="#lca_algebraic.copyActivity">copyActivity</a></code></li>
<li><code><a title="lca_algebraic.debug" href="#lca_algebraic.debug">debug</a></code></li>
<li><code><a title="lca_algebraic.error" href="#lca_algebraic.error">error</a></code></li>
<li><code><a title="lca_algebraic.findActivity" href="#lca_algebraic.findActivity">findActivity</a></code></li>
<li><code><a title="lca_algebraic.findBioAct" href="#lca_algebraic.findBioAct">findBioAct</a></code></li>
<li><code><a title="lca_algebraic.findTechAct" href="#lca_algebraic.findTechAct">findTechAct</a></code></li>
<li><code><a title="lca_algebraic.getActByCode" href="#lca_algebraic.getActByCode">getActByCode</a></code></li>
<li><code><a title="lca_algebraic.importDb" href="#lca_algebraic.importDb">importDb</a></code></li>
<li><code><a title="lca_algebraic.incer_stochastic_dasboard" href="#lca_algebraic.incer_stochastic_dasboard">incer_stochastic_dasboard</a></code></li>
<li><code><a title="lca_algebraic.incer_stochastic_matrix" href="#lca_algebraic.incer_stochastic_matrix">incer_stochastic_matrix</a></code></li>
<li><code><a title="lca_algebraic.incer_stochastic_violin" href="#lca_algebraic.incer_stochastic_violin">incer_stochastic_violin</a></code></li>
<li><code><a title="lca_algebraic.interpolate" href="#lca_algebraic.interpolate">interpolate</a></code></li>
<li><code><a title="lca_algebraic.method_name" href="#lca_algebraic.method_name">method_name</a></code></li>
<li><code><a title="lca_algebraic.multiLCA" href="#lca_algebraic.multiLCA">multiLCA</a></code></li>
<li><code><a title="lca_algebraic.multiLCAAlgebric" href="#lca_algebraic.multiLCAAlgebric">multiLCAAlgebric</a></code></li>
<li><code><a title="lca_algebraic.newActivity" href="#lca_algebraic.newActivity">newActivity</a></code></li>
<li><code><a title="lca_algebraic.newBoolParam" href="#lca_algebraic.newBoolParam">newBoolParam</a></code></li>
<li><code><a title="lca_algebraic.newEnumParam" href="#lca_algebraic.newEnumParam">newEnumParam</a></code></li>
<li><code><a title="lca_algebraic.newFloatParam" href="#lca_algebraic.newFloatParam">newFloatParam</a></code></li>
<li><code><a title="lca_algebraic.newInterpolatedAct" href="#lca_algebraic.newInterpolatedAct">newInterpolatedAct</a></code></li>
<li><code><a title="lca_algebraic.newParamDef" href="#lca_algebraic.newParamDef">newParamDef</a></code></li>
<li><code><a title="lca_algebraic.newSwitchAct" href="#lca_algebraic.newSwitchAct">newSwitchAct</a></code></li>
<li><code><a title="lca_algebraic.oat_dasboard" href="#lca_algebraic.oat_dasboard">oat_dasboard</a></code></li>
<li><code><a title="lca_algebraic.oat_dashboard_interact" href="#lca_algebraic.oat_dashboard_interact">oat_dashboard_interact</a></code></li>
<li><code><a title="lca_algebraic.oat_matrix" href="#lca_algebraic.oat_matrix">oat_matrix</a></code></li>
<li><code><a title="lca_algebraic.postMultiLCAAlgebric" href="#lca_algebraic.postMultiLCAAlgebric">postMultiLCAAlgebric</a></code></li>
<li><code><a title="lca_algebraic.preMultiLCAAlgebric" href="#lca_algebraic.preMultiLCAAlgebric">preMultiLCAAlgebric</a></code></li>
<li><code><a title="lca_algebraic.printAct" href="#lca_algebraic.printAct">printAct</a></code></li>
<li><code><a title="lca_algebraic.resetDb" href="#lca_algebraic.resetDb">resetDb</a></code></li>
<li><code><a title="lca_algebraic.resetParams" href="#lca_algebraic.resetParams">resetParams</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="lca_algebraic.ActivityExtended" href="#lca_algebraic.ActivityExtended">ActivityExtended</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.ActivityExtended.addExchanges" href="#lca_algebraic.ActivityExtended.addExchanges">addExchanges</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.deleteExchanges" href="#lca_algebraic.ActivityExtended.deleteExchanges">deleteExchanges</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.exchangesNp" href="#lca_algebraic.ActivityExtended.exchangesNp">exchangesNp</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.getAmount" href="#lca_algebraic.ActivityExtended.getAmount">getAmount</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.getExchange" href="#lca_algebraic.ActivityExtended.getExchange">getExchange</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.setOutputAmount" href="#lca_algebraic.ActivityExtended.setOutputAmount">setOutputAmount</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.substituteWithDefault" href="#lca_algebraic.ActivityExtended.substituteWithDefault">substituteWithDefault</a></code></li>
<li><code><a title="lca_algebraic.ActivityExtended.updateExchanges" href="#lca_algebraic.ActivityExtended.updateExchanges">updateExchanges</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.BooleanDef" href="#lca_algebraic.BooleanDef">BooleanDef</a></code></h4>
</li>
<li>
<h4><code><a title="lca_algebraic.DistributionType" href="#lca_algebraic.DistributionType">DistributionType</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.DistributionType.FIXED" href="#lca_algebraic.DistributionType.FIXED">FIXED</a></code></li>
<li><code><a title="lca_algebraic.DistributionType.LINEAR" href="#lca_algebraic.DistributionType.LINEAR">LINEAR</a></code></li>
<li><code><a title="lca_algebraic.DistributionType.NORMAL" href="#lca_algebraic.DistributionType.NORMAL">NORMAL</a></code></li>
<li><code><a title="lca_algebraic.DistributionType.TRIANGLE" href="#lca_algebraic.DistributionType.TRIANGLE">TRIANGLE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.EnumParam" href="#lca_algebraic.EnumParam">EnumParam</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.EnumParam.expandParams" href="#lca_algebraic.EnumParam.expandParams">expandParams</a></code></li>
<li><code><a title="lca_algebraic.EnumParam.names" href="#lca_algebraic.EnumParam.names">names</a></code></li>
<li><code><a title="lca_algebraic.EnumParam.symbol" href="#lca_algebraic.EnumParam.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.ParamDef" href="#lca_algebraic.ParamDef">ParamDef</a></code></h4>
<ul class="two-column">
<li><code><a title="lca_algebraic.ParamDef.default_assumptions" href="#lca_algebraic.ParamDef.default_assumptions">default_assumptions</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.expandParams" href="#lca_algebraic.ParamDef.expandParams">expandParams</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.label" href="#lca_algebraic.ParamDef.label">label</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.names" href="#lca_algebraic.ParamDef.names">names</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.rand" href="#lca_algebraic.ParamDef.rand">rand</a></code></li>
<li><code><a title="lca_algebraic.ParamDef.range" href="#lca_algebraic.ParamDef.range">range</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="lca_algebraic.ParamType" href="#lca_algebraic.ParamType">ParamType</a></code></h4>
<ul class="">
<li><code><a title="lca_algebraic.ParamType.BOOL" href="#lca_algebraic.ParamType.BOOL">BOOL</a></code></li>
<li><code><a title="lca_algebraic.ParamType.ENUM" href="#lca_algebraic.ParamType.ENUM">ENUM</a></code></li>
<li><code><a title="lca_algebraic.ParamType.FLOAT" href="#lca_algebraic.ParamType.FLOAT">FLOAT</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.4</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>